大家有看到我的螢幕嗎?
好,那在那個聊天室的地方
然後有同學問說
就在這個設業的地方
為什麼我們剛在計算timing pass的時候
是算B到D這邊
那確實就是這邊是投影片有出錯
那我們如果要計算第一條timing pass的話
我們是要算
就是從A這個當做起點一直要算到D
也就是要算這一條
那所以我們就現在就剛好用這個例子
來帶大家就是實際算一下
那在A這邊一開始因為它有一個input delay
是DA
那所以我們的我們的arrival time
就可以寫成是從DA開始
就要這邊要先有一個input delay是DA
然後再來到了這邊會經過一段wire
那所以這邊就是
前面有說過他wire的min delay是1嘛
那這邊路徑上就是1
那再來這個logic gate
它的min amount delay也是1
那所以這邊我們把1填上去
然後再來又遇到一段wire
那這邊也會有一個1
那再來是logic gate
所以也是1
然後再來到了這個register之前
又會經過另外一段wire
所以這邊也是1
那所以這邊整體算下來的話
我們把這些數字加起來
就會得到說它是
input delay然後加上5
也就是說
從我的資料到這邊從這邊進來開始
然後經過了這一條路徑之後
到D這個點
我的
總共的delay也就是我的arrival time
會是DA加5
那就是就是跟同學在聊天室寫的一樣
那所以
有了這個之後
那我們前面有就是大家可以
看前幾頁的input delay
然後可以看到說
A這個port它的input delay是
是1
那所以它就會等於6
那
算到這個arrival time之後
然後我們後面
後面這邊我們就要把這個arrival time
改成是剛剛原本
就是
這邊是算錯了嗎
C到D的路徑
有需要考慮嗎
也就是說這一條嗎
那確實就是在這邊有交會沒有錯
但是就是
因為根據我們的
就是現在這個example來看
我們只看
我們只看這三條
timing test
那所以說我們現在就是
等於是我們現在先忽略
C到D這一條
那但是
就是在考試的時候
如果我們是希望同學算出
建築裡面所有的timing pass
那這個時候就要考慮C到D
那不知道這樣有沒有回答到你的問題
好
好
好
那所以
我們回到剛剛D的問題
那所以說我們要把這邊的at
改成是剛剛算出來的6
那這樣算出來的話
這邊的slack它就會變成
那所以
這邊的話同學就
可能再自己做一下修正
那這樣算出來的
之後還是會發現說
這條pass它有timing violation
那再來的話
因為剛剛就是同學有問到說
那如果考慮C到D的情況會變怎麼樣
那因為剛好就是
期中考可能也會有類似的題目
那我們就這邊再
帶大家再做一次
那我們就從set up time開始
就是如果我們現在多了
C到D的這一條
那C到D的話大家可以去看
我們現在的這個
那C到D的話大家可以看到說
它也是屬於
就是第一種
是
input到register
那所以說它的arrival time在這邊
我們就是要先從它的input delay
開始去做計算
那就會變成像下面這邊一樣
是從input delay
然後再加上
我們把這些
路徑上面的maximum delay
因為這邊是set up time
所以我們把maximum delay填上去
那這個wire就是2
然後logi gate的部分就是3
再來是2
然後3
然後2
那這邊的話就變成是它要再加
那比較特別的是就是在這邊它有一個交匯
那所以說我們就要先算到這個交匯
要先算到這個
這個節點來看
到這邊下面這條pass它是7
那到中間這一條的話它的pass是
12
然後再來上面這條pass
它是10
那所以說我們這邊就用12來當做它的這個
最終的maximum delay
那這邊算出來的結果的話
就可以發現說它是
12然後再加3再加2
所以就變成是
17
那這是它的rival time
好
那所以到後再來
再來我們就要算它的require time
那require time的部分
因為它也是屬於第一種pad是input register
所以基本上它的require time跟這個算法是一樣的
也就是17ns
這邊就是11到
D的那條pass
它require time是17ns
那再來再算slack的話
我們就要把它
的require time減arrival time
所以就是17
然後減掉前面得到的
這邊是18嘛
那所以就會變成是輸ens
那就代表說
這一條路徑它也是
timing violated
不知道這樣子
大家就是有沒有
就是有沒有問題
那比較特別就是在中間的
在中間的這個pass有交會的地方
我們可能會需要考慮比較多情況
好那再來是hold time的部分
一樣我們假設
現在多考慮了下面的這個C到D的pass
那這邊的話我們會首先
以arrival time來看的話就是
這樣也是照剛剛的算法
那這邊就是
在那邊就是這個input delay
要先把這個input delay
再把這個input delay
再把這個input delay
在那邊就是這個input delay要先
加上來
然後再去算它每個pass
中間的delay是多少
然後再這樣慢慢往前算
那就可以得到說
這邊往前算的話
我可以得到的是
這個節點是
6嘛
那這邊是3
所以這邊也是一樣用6
這邊要用3因為是hold time
那所以3
那所以這邊我就可以得到說
它的hold time是at
然後加上這一段的delay是3
然後再加上後面這兩條pass上面的delay是2
就可以得到說
我這條c到d的pass
就會變成是input delay
然後加上5
那再來是它的require time的部分
那因為一樣它是屬於input to register的
那所以它在require time的部分
算法會跟tie-in-pass 1是一樣的
也就是結果算出來會是7ns
那再來到hold stack的部分
就是同學這邊就可以自己去算算看
它算出來的結果應該會是
就是如果我們按照一樣的算法來做計算的話
那這裡的話它計算出來的結果就是
前面的
tie-in-pass 1的結果
就是tie-in-pass 2的結果
它計算出來的結果就是前面的input delay
然後加上它的
就是到中間節點是3
然後再加上2
再去減掉require time是7
那這邊的話一樣就可以算出來它是
出1ns
好那這邊就是
就是再舉一條tie-in-pass
然後計算給大家看
那大家如果有問題的話就可以在聊天室發問
謝謝大家
那剛剛他在哪裡
喂
好那前面
如果剛剛STA的計算方式
大家還有問題的話
那就可以一樣在聊天室發問
那接下來我們就繼續
接下來的內容
那接下來我們會帶大家看一下說
要做STA的話我們會需要怎麼樣子的
環境設定
那首先是library data的部分
那
library data的話它包含了
就是第一個是cell delete model
那它在這個cell delete model
它分成兩種
第一種是linear delete model
第二種是nonlinear的model
那這兩種model
它們的差異在哪裡後面也會有
介紹
那接下來是
除了這兩個model
delete model以外我們在跑
就是合成或是跑模擬的時候
也會需要去告訴我們一些
tool說我們今天
希望我們的電路是跑在什麼樣的
那以下面這兩個command的
例子來說的話
我們的
第一個就是我們在設定
我們的operating condition
那我們這邊是把它設成typical
那再來下面這邊的話
對於wire load
它也會有一個固定的delete model
那這邊的話
就是我們的operating condition
也是一樣可以做設定
那這裡我們也是先講說它設成typical
那這兩個就是
一個
範例的指令讓大家
知道說在EDA tool
裡面如果想要設定
operating condition的話該怎麼做
那接下來是linear cell
delete model的部分
那這邊
大家可以看到說它的model基本上就是
像是這張圖
一樣重軸是它的delete time
然後橫軸則是它
對應到的output capacitance load
那基本上它叫做linear
那所以它的delete就是
跟這個output的
capacitance是呈現線性的關係
也就是說我的這個
capacitance越大的話
那我的delete就會跟著成長
那這邊就會有一個斜率AC
那這個AC它指的就是
下面這邊的這個drive
impedance
所以就是乘上這個C之後
然後再加上原本
trinsic的delay
那我就可以得到說
那所以我現在這個電路
它對應到的delay是多少
那再來剛剛提到說
有兩種不同的celldelete model
那這邊就是第二種
也就是nonlinear celldelete model
那這種model
因為它是nonlinear
也就代表說它沒有一個特定的公式
可以去
對delay做存取
那所以說在這裡我們會
需要用到一個
delay table的東西
那這個delay table它裡面會存兩種
不同的資訊包括了celldelay
以及transitiondelay
那大家可以想成是
就是它把一大堆的數字存在table裡面
那我們有需要
再用查表的方式
然後去對它做存取
但是因為
這種存成delay
table的形式它可能沒有辦法
就是完整的去
考慮到所有可能的使用情況
那所以今天如果我們發現
我們的delay沒有
辦法透過delay table裡面的
數值得到的話那這個時候我們可能
就會用就是比較接近的
delay然後用interpolation
的方式去找到
我們預期希望可以拿到的delay
那接下來我們就來看一下
一個delay
table裡面就是包含什麼東西
那前面有提過它
存了兩個不同的數字
第一個是celldelay
然後第二個是transitiondelay
那它可能就會有
就是對應的一些function
那基本上都是很多數字讓
使用者去做查表
那下面的話就是
查表的方式我們
它查表的時候它
有兩個不同的就是參考
標準那第一個是input
transition
第二個是output capacitance
那例如說今天如果我
跟我的delay table說我現在
的input transition是0.5
然後output capacitance是0.2
那它就會告訴我說
那現在這個電路它對應到的delay
就是中間的
這個0.432
好那接下來是operating
condition的部分
那什麼是operating condition呢
我們現在可以想像一下
就是我們電路在實際運作的時候
它有時候可能
它其實有時候可能會在不同的process
也就是不同製程或者是
它會遇到不同的工作電壓
甚至是我們平常
空氣中的溫度也不一樣
也就是它會有不同的temperature
那這三個
這三個variation合起來我們會把它叫做
PPT variation
那operating condition它就是希望能夠去
model這三個不同的
variation
那大家可以看到下面這一張圖
就是這三張圖表
那就是以左邊
這張圖表來說的話
重軸是process
重軸是delay那橫軸是process
那大家可以看到說
隨著我的process
越往右邊可能是
越差那這時候我的delay
可能就會越大
所以這邊worst case的時候我的delay可能
就在最上面
那可是我隨著我的process
越好的話
那這時候我的delay當然就會變得越小
所以best case
的delay就會在這邊
那這樣子condition的model
方式它是用
scale scaling的方式
所以可以看到說它這邊大致上
呈現一個線性的數值
那右邊兩個就分別是
voltage和temperature
那可以看到說在這三張圖裡面
best condition它指的都是delay
最小的情況
也就是例如說制程是最好的
然後voltage它可能是最大的
就是電壓越大
那我的電度它工作的速度越快
那在temperature來說的話
它可能就是在溫度比較
適合半導體
工作的範圍裡面
就可能是越小
然後它的delay就越小
那worst case
則是表示這三個情況
這三個不同的variation裡面
它的delay最大的
的那個
就是那個delay
那typical則是在best跟worst之間
好
那再來是wireload model的部分
那這裡的話
就是這邊是一個wireload model
它存取的範例
那大家可以看到它裡面存了很多
wired可能會用到的參數
那包括了
包括了rce的數值
然後以及這個wire它的
面積還有像是
它對應的fanout是需要多少
是需要怎麼樣的規格
這邊都會在library裡面
有定義號
那所以在做STA的時候
基本上如果我們想要知道wire的delay
那就是從這些rce
以及area等等的
去對它做計算
像下面這邊
那就可以得到最後
就可以得到最後這個wire對應的delay是多少
好
那再來就是
準備好了前面那些library
之後呢
我們再來還有一個很重要的步驟就是要定義我們的
clock
那對於clock而言
我們在做synthesis的時候
是需要對它做非常準確的
定義
就是我們如果能夠定義好一個準確的
timing constraint的話
那我們才有辦法在比較早期的
去知道說我們這個
design就是設計出來的電路
它有沒有辦法達到timing
convergence也就是說我們的
timing constraint到底
有沒有符合我們這個電路設計的標準
那要定義一個準確的clock
需要哪些東西呢
我們可以看到下面這邊
第一個當然就是它的週期
或者是它的工作頻率
那第二個就是
這個clock為它的wayform的形態
那我們後面會有
比較詳細的例子做說明
那再來就是
包括了前面有講過的
clock latency以及clock
uncertainty的部分
那這邊的話
就是像前面所說的latency
包含了source latency以及network
latency然後uncertainty
可能就是一些clock skew等等的
一些電路裡面
的不確定性
那有了這些
定義好的clock
timing constraint之後呢
那這個時候就是
就代表說我們的timing
class是已經有被規範了
那這也是讓大家看一下
clock它的週期和wayform
的定義方式
那要定義一個完整的clock它的wayform的話
我們會需要三個不同的參數
第一個是它的週期
也就是前面有講過的tcycle
那這邊
就例如說在這個例子的話
它是10nx
那第二個是clock
的rise time
也就是這邊的trise
那它這邊就是指說
我的clockage從0
到拉起來這段時間
它是多少
那fulltime則是跟rise time相反
它就是代表說我的clockage
從1到0
的這段時間是多少
那以上就是
我們在做STA的時候
會需要對環境做的
一些設定
那最後我們來介紹一下
就是在電路裡面
我們可能會遇到一些比較特殊的timing paths
像是最一開始
有跟大家介紹過的false paths
那這個部分的話
我們接下來就會介紹給大家說
他們指的是什麼東西
那首先第一個是false paths
那什麼是false paths呢
就是今天當我們在
設計電路的時候
因為我們如果拿這個電路
直接去做STA的話
STA會幫我們
做全面的檢查
就是每一條path都拿出來做檢查
那可是今天我們
在設計上
可能我們本身就知道說
有些paths我不想要讓它做STA
因為它做了
因為就算它出現了timing violation
它也就是對電路整體
沒有任何的影響
那這個時候我們就可以把這一種timing paths
設定成是false paths
那一旦我們把timing paths設成
false paths之後呢
在做STA的時候它就會被忽略掉
也就是不管它的timing有沒有過
我們的EDA tool都沒有
那接下來我們來看一下
有哪些paths可能會被
designer設計成是false paths
那這邊是五種不同的例子
包括了un-exercised paths
還有irrelevant paths
以及asynchronous paths
然後logically impossible paths
然後最後是combination loop
在做false paths的時候
它可能會有
un-exercised paths
然後
在做false paths的時候
因為前面有提過說
STA會直接忽略掉
被設定成false paths的timing paths
那所以說今天如果我們設定錯了
把一條本來
應該是critical paths的timing paths
設成false paths
那這個時候
我們如果一直忽略掉它
沒有去對它做改善的話
可能到最後我們設計出來的電路
就會fail
那所以在使用上它必須要
要很小心
那接下來我們就來看一下前面提過的
五種不同paths
就是它是什麼樣子的paths
那
首先是un-exercised paths
那它指的是
在普遍的情況下
不會被用到的paths
那普遍情況下就是
可能一般我們在
日常使用上它不會用到
那其中一個
就是例子的話
大家可以看到下面的這張圖
在這個電路裡面
我們中間插了一個
叫做probe的test register
那大家可以知道說
test register它是只有在
對電路做debug
或是對電路做測試的時候
才會用到
那平常我們可能例如說消費者在用的時候
基本上是不會去啟動它的
那所以說
今天如果我們發現
我們有一條timing violation
發生在這個probe上
那這個時候
因為我們本身就已經知道說
這個probe它只有在
測試的時候才會用到
然後在做測試的時候
我也不會太在意它的
就是它的工作頻率
應該要是多快
那所以這個時候我們可能就可以把它設定成是force paths
那這樣子的話
我們就可以避免說
電路的其他地方
被這個平常不會用到的
test register給綁住
就是它的頻率不會被它給限制住
好,那再來是 irrelevant paths的部分
那這邊的話
它指的是
就是它雖然在
電路裡面存在這一條path
那可是它的timing本身就已經很慢
或者是我們其實不會太在乎說
它應該要多快
那但是
那跟前面的相比的話
最大的差異就是這一條path平常會用到
好,那
那這邊
舉的一個例子就是
這個reset signal
那假如說今天我們的電路
用到的是synchronous reset
也就是說它在reset之後
它會插一個這個reset register
那這個時候如果我們發現
這個register上
有一條timing violation的path
那可是因為我們知道說
在做reset的時候
它可能可以reset好幾個cycle
甚至好幾百個cycle
那所以說我們最終目的
只要它能夠完成reset
不管它花幾個cycle
我們都沒有問題的話
那這個時候我們就可以把它當作是
irrelevant paths
也就是說它不會影響到我們電路正常的功能
也就是正常的運作
那再來第三個
是asynchronous paths
那這條path的話
它指的是
一條在兩個不同的
clock domain之間運作的path
那大家可以看到下面的這個例子
那左邊
這個register它是在clock 1
的這個domain
那右邊的這兩個register就是在clock 2
的這個domain
那中間的這一條path呢
我們可以看到說它從
這個q
連接到
右邊的這個d
那所以說就可以很明顯
看到說它是穿越的clock 1這個domain
以及clock q這個domain
那所以
這一條path我們就可以叫做
把它叫做asynchronous paths
那基本上
如果電路裡面出現這條path的話
我們一般會把它叫做clock
domain crossing
那這個時候就是它其實是
一個很容易會出現time violation
的path然後在資料
存取上也會非常不穩定
那這個時候呢
我們就會需要把它設計
設計成是false paths然後用
一些比較進階
的technique去對這些
去做這條path
去做調整像是
以這個例子來說它就是在後面右接
的第二個register就是希望
能夠去捕捉這條path傳送
進來的訊號
好那再來是
logically impossible paths
那在這邊的話
它指的是在電路當中可能存在
這條path但是沒有任何
的input vector也就是任何的
pattern會去觸發它
那大家可以看到下面這一張圖
就是中間有兩個
max u0跟u1
那它們兩個都連接到
的相同的這個select訊號
那所以說
如果就是這個對於
這個select來說它只可能
它傳送到這兩個max的時候只可能
同時是0或同時是1
那所以說在圖片中
這條紅色的path
也就是從u0的這個
1到u1的這個
0的這條path
基本上是不可能會被
使用到的那它就是
所以這邊就是logically impossible paths
那
那所以在這邊
如果我們今天發現到
這一條path上有time in relation的話
我們其實也可以把它設定成false paths
因為我們可以百分之百確定說
它永遠都不可能被使用到
那最後是combination loop的部分
那在這邊的話
因為STA
在最一開始有提過說
STA它的就是終點跟起點
只會有
三種情況嘛就是要嘛是
起點是
register或是input port或是output port
然後終點也只能是register
input port或是output port
那所以說今天如果我們電路裡面
有combination loop的話
那等於是對於STA來說它沒有任何
的起點或終點
那這個時候它就會不斷的
在裡面去做一些
就是前面timing graph的delay的運算
那所以這個時候
它可能就會影響到
就連帶影響到其他path
在算arrival time的時候
那這個時候我們就
需要把這條設定成false path
讓STA
忽略它才不會影響到其他
path在算arrival time的時候
的
就是影響到它們的結果
那接下來是第二種
就是特殊的timing path
那這邊我會把它叫做morticycle path
那什麼是morticycle path呢
它指的就是
在電路裡面可能有一些
combination logic
它需要運作的時間
也就是它delay特別的長
像是懲罰器或是處法器
那但是後來可能
我們分析之後發現說
其他path它的timing
可能都在例如說5ns
3ns那結果只有
這一條path因為有了處法器
所以可能變10ns甚至20ns
那這個時候我們就會很不希望說
我們整個電路
因為這一條path
而被限制住頻率
那所以這個時候我們就可以
把它設定成是morticycle path
意思就是讓這條path
可以工作多個
cycle
那我們電路的其他地方就是
在多個cycle之後再去access
它的結果
那這就是morticycle path的意義
那這邊用一個
懲罰器當做例子
就是左邊就是對應的電路
的block diagram
那可以看到說它就是包含了
中間有一個16bit的
懲罰器
然後它的opv會是32bit
那右邊是對應的RTL code
那個大家可以就是
再自己對照一下
那如果我們今天把這個電路直接
拿去做合成的話
大家可以看到左邊的這三行指令
所以第一行它指的就是
我們今天的電路是
合成在
period是4ns的情況
底下
那我們合成之後
然後請我們的EDA tool
幫我們report
它這個電路的timing
那就可以得到右邊這張圖
那右邊這張圖
大家就可以發現說
我的這個電路它現在的timing
我覺得它的slack是負的
那我們仔細分析之後可能就會發現說
那這條pass它是經過了
那個multiplier
這邊有一個mult
它是經過了那個multiplier之後
然後才發生的timing violation
那如果這個時候
我們希望能夠
維持住這樣子的
工作頻率的話
那我們這個時候就可以試著把
這個懲罰器設定成
是multicycle pass
那這邊是我們設定的方法
那上面是
對應的指令
那這邊主要是讓大家就是
稍微感覺一下說
我們現在如果想要
讓我的懲罰器多
工作一個cycle的話
那大家可以看到這個setup check
這個藍色的箭頭
原本我們的懲罰器它可能是
只能工作一個cycle
也就是它的setup check會在這一條
edge上
但是現在我們如果讓它
工作兩個cycle的話
等於是我們要推遲一個cycle再去做setup的檢查
那所以說
在這邊的話
我們把它推遲一個cycle之後
這個懲罰器
它就總共有兩個cycle
可以去做懲罰
那我們做好了
這個multicycle pass的設定之後
我們再拿去做一次合成
那我們合成後
一樣請EDA tool
report出這個
design的
timing
那我們這個時候就會發現說
我的slack變成是正的
也就是我的timing是matte
那我們仔細去看這個報告
就可以發現說它的critical pass
雖然一樣是在multiplier上
但是這個時候
它在做setup check的時候
它的rise age變成是8
那也就是說
現在這個
STA知道說
我這個懲罰器我希望它能夠
工作兩個cycle
所以從原本的4變成8
那它在兩個cycle之後
再去對這個懲罰器的結果去做檢查
那所以這個時候
我們就可以成功的
讓我們的電路是可以
pass整個timing constraint
好
那最後就是今天課程的總結
那我們今天
我們今天最一開始就是先讓大家
體會一下timing analysis
對於數位電路設計上面的重要性
那因為
現在數位電路基本上
都是synchronous design
就是它會有clock這個訊號
那所以說
我們的電路能不能夠通過timing analysis
或是timing check
就變成是非常重要的
就變得非常重要
因為如果它沒有辦法通過的話
那它什麼時候會產生fail
然後會產生function上面的錯誤
這個是我們沒有辦法預期的
那整塊晶片
也就會變成是沒有辦法用
因為就是像是說
如果我們今天有一台電腦
然後結果它有時候在計算
它有時候在計算數學的時候
它有時候會算錯
那這個時候基本上沒有人想用吧
那再來第二個部分
我們有介紹兩種不同
timing analysis的方式
包括了DTA和STA
那我們也有討論到說
DTA
它的缺點在哪裡
然後為什麼現在主流都是用STA
然後再來是
第三個
也是今天課程最重要的一個部分
那這邊我們是教大家要怎麼去計算
要怎麼去做STA
那首先就是要先把
我們的一個電路
把它timing path給拆解出來
然後再來就是一條一條path
去算它的arrival time以及require time
那算出來之後呢
再用arrival time和require time去算
他們各自的slack
然後用這個slack來判斷
我們的就是對於一條path而言
它的timing有沒有符合
timing constraint
那這邊的話就是今天課程最重要的部分
然後
大家如果去看
就是現在的很多DTA圖
在計算上也是用這個方式在算的
那期中考的話我們也是
在這個章節可能會從這邊出題
那接下來第四個部分的話
我們有介紹說要做STA的話
我們需要環境做哪些設定
像是可能
我們會需要準備好
cell跟wire它的delay
然後以及我們需要幫
我們的EDA tool設定好說
我們預期希望的clock訊號
它的波形長什麼樣子
然後以及還有相關的
像是latency
uncertainty上的constraint
那最後的話我們則是有
介紹了兩個在電路裡面
算是比較特別的timing paths
包括了force paths以及
multicycle paths
那這兩個的話大家現階段可能
還不太會去使用到
那但是這邊就是先給大家一個概念說
我的電路裡面它可能
不是所有paths都
一定要就是時時的
一個cycle做一件事情
那有些東西它可能是
可以透過這兩個
不同的paths然後達到更大的彈性
好那以上就是今天
課程的內容
那再提醒大家一下
這個static timing analysis
它都是用worst case
下去計算
這裡的worst case有可能是最長
有可能是最短
這個取決於你是要算setter time
或後time不太一樣
但是反正它是用worst case
那這個跟同學在跑模擬的時候
這種是
這個pattern dependent
是不太一樣的
這裡的worst case如果在某個
logic gate你希望去量
的是它這個最長的delay
那你在測
這個pattern的時候有可能
那一個pattern不是那個
worst case就會造成
他們嚴格來說是不是
完全一致的結果
但是因為它static timing
analysis是最差的情況
所以你在static timing
analysis在這邊
有通過它這個timing的檢驗的話
你在跑那個pattern的時候
就都要會過
可是話說回來如果你的static timing
analysis
看起來好像是沒有過
因為有同學之前好像問過類似的問題
如果你在做這個synthesis
的時候其實還差了一點沒有通過
那是不是你的模擬就一定
不會過呢
但是因為兩邊的condition不太一樣
如果你在跑這個pattern的時候
並不是碰到那個worst case
說不定從
這個概念上來說
你並沒有違反它的timing
不知道同學有沒有了解這個意思
就是在做static timing
analysis的時候都是取那個
最差的情況
對任何一個logic gate來說不同的pattern
不同的input或者是你看
不同對應的output其實它
delay都略有不同
static timing analysis都是取那個最差的
但是你跑pattern的時候
未必會碰到那種case
所以你不見得就剛好
在那一次模擬的情況底下就得到
錯的結果
只是因為你沒有碰到
那一種condition
所以希望同學這部分的話
注意一下
可是話說回來呢
如果你這個
這邊在synthesis的時候
都已經timing
檢驗都過了
但是在跑pattern的時候卻有問題
那你優先
要去考量的是說是不是兩邊
在這個環境的設定上
有不一致的地方
這個包含你的condition
是不是一樣
你的這些wire delay是不是完全相同
照理說的話呢
是static timing analysis有通過的話
那你在跑pattern的時候
就應該都要能夠通過才對
那個俊偉好像
有人有問題
你再看一下
好
有同學問說就是在第37A這邊
timing pass
1是不是也應該要改成
DA加14
就是可能是因為這邊
有一個交匯點
就是這邊
就是經過剛剛跟其他助教討論
的結果是說
這邊其實應該正確的算法
就是每一條pass他自己去
算他的delay
所以剛剛我們後面在算C到D的時候
那樣子的算法其實
是不用考慮交匯點的
就是直接每一條pass算他各自的delay就可以了
後面好一題喔
你再看一下
DC加17
可以講一下
是第幾頁嗎
37A的話
就是像剛剛我們講的
就是剛剛我在算的時候
是
找到這邊這個交匯點的
worst case的delay
但是剛剛跟其他助教討論的結果是
其實我們只要算
就是這一條pass他自己的delay就好了
那所以說
這邊確實應該要改成是
原本的DC然後再加上
路徑上面他自己的delay
也就是
對
那
你再看一下
那他自己的delay
是
是
是
是
是
是
是
是
是
是
是
是
是
那有同學問說
就是為什麼我們前面在講timing graph
的時候
是要考慮
交匯點的嗎
那這邊的話
就是
可能我們回去
再確認一下
然後再可能過幾天
再跟同學回答一下
然後
再來最後一個同學是問說
那些指令只要看得懂
不需要能默寫出來是
對的
我們不會要求同學默寫指令
那些都不用背
我們是
工程師啊
我們又不是這個社會主的
背那個東西沒有什麼用啊你只要看得懂就好了
那如果
沒有問題的話我們等一下還有
label就是現在差不多
4點10分
我們休息10分鐘之後
我們就開始
我們就開始
我們就開始
我們就開始
我們就開始
我們就開始
我們就開始
我們就開始
我們就開始
我們休息10分鐘之後
4點20回來就label這樣
