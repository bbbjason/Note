可是需要讀進去的東西其實很多
我們把需要吃的資料分成兩個部分
一個部分是Library的部分
另外一個部分是User Data的部分
Library的部分指的是
需要從Sale Library那邊取得的資料
叫做Library的部分
就它算是Sale Library提供的內容
它不是一般User直接就可以自己做出來的東西
User Data的部分就是自己的內容
就我們的Netlist還有我們的Contrains
就算是User Data的部分
先講Library的部分
大家在做合成的時候
應該有用過Synthesis Library
就我們的Synthesis是吃DB File
就當成它的Synthesis Library
實際上DB File它就是這邊用的 Timing Library
只是Innovate它吃的檔名
它不是吃Library的格式
它是吃DB File的原始檔
就還沒Compile之前的檔案
它只是Library的 Timing Library
所以 Timing Library在APR這邊同樣會用到
因為這裡面有每個元件的功能
Function的設定還有它的Delay的內容
全部都在 Timing Library裡面
所以 Timing Library在APR這邊就一樣會用
實際上 Timing Library主要有三種格式
它們叫NLDM CCS和ECSM
CCS和ECSM是比較新的格式
它是一個Current Source的Model
它在計算 Timing Delay的時候可以算得比較精準
所以如果大家拿到Library裡面有提供這種格式的話
就盡量使用CCS或ECSM格式的Library
Physical Design除了Library之外還有其他的部分
主要的部分第一個是我們會需要Physical Library
Physical Library它是Left格式
它主要的內容是這個製程的一些
我們至少要知道我現在做這個製程
這個製程有多少層Metal Layer
這些Metal Layer的一些基本的Design Rule
我們都必須要知道
那些東西全部都寫在Left裏面
所有使用到的元件
那些Scranial Cell的形狀
還有Iopad的形狀
或者SRAM的那些形狀
那些資料也都是寫在Left裏面
所以Physical Library當然對APR來說是一個很重要的Library檔案
再來是APR它需要做RC催旋
因為在繞線繞完之後
我們會需要知道說這些繞線它的負載多大
所以它需要做RC催旋
RC催旋的時候就會需要這種Coverage Table
就它要有這種Coverage Table
才有辦法去做一催的RC
Coverage Table其實有兩種格式
這兩種都算是Coverage Table的格式
最後是Noise的資訊
Signal和Signal繞線太近的時候
它就只會互相Cross-talk
它會互相干繞
所以我們要分析這種Cross-talk的效應
就會需要有這種Noise的Library
主要的格式是CDB的格式
前面講到的那個CCS
Timing Library有CCS和ECSN的格式
Noise的資訊也可以寫在這兩種格式裏面
所以如果大家有CCS或ECSN的話
你就可以不用CDB
因為本身有CCS和ECSN就可以算Noise
所以那時候Noise Library就不需要
假設我們是用NLDN的話
就一定要有CDB Library才可以做Noise分析
這是Library的部分
User Data的部分
Gate Level Netlist是一定要的
這是合成之後的Netlist
這是必要的東西
我們必須要把IoPAD的手動線
把它加到Netlist裏面
假設在合成之前還沒做的話
就要在合成之後把IoPAD的把連線連上來
我們需要給SDC Control
就告訴Tool說這個Design的一些Clack資訊
或是Io的一些資訊
後面有兩個檔案叫MMC的File跟IoAssignment File
這兩個檔案有的話當然是最好
沒有的話也可以用Tool提供的GY產生出來
這個就不是必要
但是如果你有的話就可以直接帶過來用
所以在下我們就看到Import Design的介面
一開始我們軟體叫起來之後
大家就會先叫出Design Import的這個介面
在這個介面裏面
我們就把剛才提到的WRG File要填入進去
然後我們的Top Sale的名稱也填好
然後Left的部分
Left的部分其實不止一個檔案
因為Left裏面其實有些Left是Standard Sale的Left
有些是IoPAD的Left
然後有些可能是SRAM的Left
所以我們可能有很多個Left
然後填Left的資料的時候
有一個很重要需要注意的是
它有順序的問題
它的問題是Technology的那個Left
一定要放在第一個
因為Tool它一定要知道先吃Technology的Left之後
它才知道說這個製程有哪些Metal Layer
然後它的一些基本的一些
Sale-based的一些規則的定義都在TechnologyLeft裏面
所以TechnologyLeft一定要先吃
吃完之後一般的Sale-based的Left它才看得懂
所以也就是說它會有那個順序的問題
那最後有一些Left它是記錄Atena的資訊
Atena其實是一個Design rule的一個內容
就假設大家在Library裏面有看到有
檔名有帶ANT或者帶Atena的這種資訊的Left
你把它放在最後面一起填進去就可以了
這是Left的部分
那IoE Assignment本來應該是要停在這裏
但是我們先把它空著先不要填
我們先看後面
PowerNet和GroundNet這邊我們需要先填入Vdd和Vss
填這兩個內容填這兩條Net名稱的意思是說
我們需要Tool自動幫我們產生一條Net名稱叫做VddNet
然後另外一條Net叫Vss的名稱
因為上面的這個GatelevelNetlist
GatelevelNetlist通常只有定義方圈的連結
也就是方圈Pin的連結
那實際上每一個Sale它都會有Vdd和Vss的Pin
可是在這個Netlist裏面並不會描述
那個VddVssPin的連結是怎麼做的
所以我們要做APR就必須要把那些Vdd和Vss的連結
把它補起來讓Tool能夠有一個完整的Netlist
那補起來的階段先分幾個階段
第一個階段就是要先定義出我的底下裏面有這兩條Net
那之後底下硬碰完之後
我們會把Sale的VddPin再把它指定連接到
現在的這個Vdd的PowerNet
Sale的VssPin再連接到這個Vss的GroundNet
這個是Vdd上面的連線定義
那總之這兩個名稱就先把它填好就是了
前面我們看到還有一些什麼
Timing Library或者Common Table或者是Node Library
這些內容它都放在那個MMC的設定裏面
所以待會我們會看到MMC的設定有哪些
就算是一個比較大的一個需要學習的部分
它有Tool提供一個介面叫MMC的Browser
可以讓我們去設定這個MMC的內容
那我們先來看那個IoAssignment File
我們Design其實有很多個IoPad
就比較有些Design它可能IoPad數量很多
有一兩百根的那個IoPad
那IoPad它是放在整個Chip的最外圈的這個
最外圈
因為我們的數量這麼多
所以你要用滑鼠去搬動這些Sale擺放它的位置
其實其實不make sense就我們很容易做錯
所以我們實際上擺放Io的做法
是提供它一個IoAssignment File
就像是右邊這個文字的內容
那這個IoAssignment File是把一個Design分成是八個方位
分別叫Top、Right、Left、Button
這個上下左右四個方位
那另外有四個是Top、Right、Top、Left、Top、Button
和Button、Right和Button、Left
就是右上右下、上左下四個方位
這叫四個角落的方位
然後有哪些Sale
有哪些IoPad我們希望把它放在上面的部分
Top的部分
我們就把它寫在Top的這個區塊裡面
所以這個X4、X5、X6這三個Pad
我要放在Top這裡就把它寫在這裡
然後Left這邊X1到X3
我想要放在Left左邊這個地方
然後就把它寫在Left的這一區塊裡面
這樣子就可以把Pad就分成四個
所以我們的Pad就可以把它分成四邊分攤開來
那另外一個問題是
同樣寫在Top的這三個Pad
哪一個會在左邊哪一個會在右邊
這個就叫IoOrder
Default IoOrder就叫做Default
Default IoOrder的意思是說
它擺放的時候它會從左邊往右邊擺
然後從下面往上面擺
也就是那個第一項線的座標
就第一項線我們在X和Y都是由往右邊和往上面成長的
所以在Top這邊從上面456寫下來的時候
實際上在Layout上面就是從左邊456把它擺過去
然後Left這邊123、S1、S2、S3依序寫下來
實際上就是由下面往上擺上去
這個叫Default IoOrder
再來是我們會需要加進那些PowerPad和GroundPad
就前面有提到過
Physical Design需要加PowerPad和GroundPad
但實際上我們前面Design Import的Netlist
並不會有PowerPad和GroundPad的宣告
所以這時候我們怎麼做
我們的做法就是
假設我希望在右邊這個地方加進一個VDD的PowerPad
那我就直接在Write這個區塊裡面
給它一個InstanceName
這InstanceName是自己隨便取的
就你可以給它任何的名稱
然後Tool它不曉得這個Instance是什麼東西
所以我們後面還要再加一個參數叫Sale等於某一個SaleName
告訴它說前面的Instance它其實就是這種Sale
實際上這是一個CodeVDD的PowerPad
CodePowerPad
所以用給它Sale的這個參數的方式
我們就可以額外的塞入自己想要塞進去的東西
就包括CodePowerPad和CodeGroundPad
還有Io的PowerPad和Io的GroundPad
都是用這種方式輸入進去的
所以這個應該這樣子
這樣子我們其實就可以把所有Io都把它先設定好
使用文字的方式的好處就是
我們可以任意的去做Copy Paste
就在調整它的順序上面其實會比較容易
那另外有四個比較特殊範圍是那種
右上右下左上左下這四個範圍
這四個範圍它裡面都只有一個CornerPad
CornerPad的功用是用來連接PowerIn
就大家如果翻到前面的投影片
可以看得到CornerPad的長相
就CornerPad它是把PowerIn轉角的一個元件
那我們如果Design是四周都有IoPad的話
我們就會需要四個CornerPad
讓PowerIn能夠串接成一圈
串接成一整圈
而這四個CornerPad在Netlist裡面當然也是不存在的
所以加CornerPad的做法跟加PowerPad的做法其實一樣的
就直接給它一個InstanceName
然後告訴它說這是哪一種Sale
就可以把CornerPad把它放進去
所以這個就是IoAssignment File
只是說因為我們的Pad的數量太多
我們有IoPad的數量小的Design它可能二三十個
大一點的它可能就一兩百個都有可能
所以要一個一個去key這些名稱
或者要把這個格式把它沒有任何錯誤的把它打字打出來
其實本身是一個問題
所以我們建議的流程其實是這樣
一開始在做Design Input的時候
IoAssignment就先不要填
保持空白先不要填
空白的意思就是不給它任何Control的意思
那Tool它擺的時候它就會先隨便亂擺
Tool之後就Design Input做完之後
Tool會隨便亂擺說我們一開始可能就是先做Design Input
然後Tool自動就幫我們隨便把這些Io擺好
擺完之後我們可以要Tool把Io的IoFile寫出來
就用DesignSafeIoFile
要求把它把IoFile寫出來
寫出來格子就會有點像右邊這樣子的格式
這個就是一個IoControlFile的格式
然後在格子裡面可能會有一些看不懂的東西
這些東西你要把它刪掉也沒有關係
把它保留著其實也沒有關係
它不會影響到我們的Io的設定
所以我們接下來要做的工作就是
把這些名稱把它排列成我們想要的排列
就我們要根據自己想要的Io擺放的位置
把這些Io先擺好
就是做文字編輯的工作把這些順序擺好
然後我們可能會需要
把需要加進PowerPad或是光Pad的位置也把它加進去
那CornerPad也可能要額外再加進去
那也許有些Design它可能用到其他的Pad
比如說MLPad或是PRCut
都是用這種方式把它加
都是用IoAssignmentFile的方式
把它塞到我們想要的位置
修改完IoAssignmentFile之後
最後才再用Load的指令
再把Io的指令改完的結果把它讀回去
那讀回去之後你在列要上面
你就會看到它馬上就更新了
Io的位置馬上就會更新上去了
所以這樣子在流程上應該會比較順
就不會擔心說打錯字的問題
因為只要是人在操作就一定會出錯
所以能夠讓Tool做的話就盡量讓Tool去指令
所以這是Io部分
那再下來再講到就是MMMC
剛剛Design Input介面
IoAssignment部分我們講完了
那我們就可能會需要去設定這個MMMC的設定
MMMC的設定是
這個概念其實大概是
大概應該也有十年了
在更早之前
其實我們的Design其實沒有這麼複雜的時候
那個時候的Tool
它在設定上
在設定做Timing設定的時候
其實我們大概是這個狀況
我們會給它一個SDC File
就只有一個SDC File
那不管Design多複雜
我們Design如果有很多操作模式
不管怎麼樣
我們會把所有的模式都寫在同一個SDC File裡面
然後我們會給它一組Timing Library
這個我們叫Meshima Timing Library
它是一個比較低的電壓
它是標準電壓的0.9倍的電壓
然後可能是比較高的溫度的一個Corner Library
在因為Sale在這樣子的狀況之下
它的速度Delay會比較長
它的速度會比較慢
所以我們把它叫做Meshima Timing Library
它Delay值比較大
或者你可以叫它做Slow的Library
那這一組Library
我們會拿來做Self-Type的分析
因為Self-Type是要求Tool能夠跑得夠
應該說它要求Sale能夠跑得越快越好
所以我們會用相對悲觀的Library
它要我
我們會用最差狀況的Library去做Self-Type分析
假設我用Meshima Timing Library
做分析出來的結果是對的
那其他Library理論上也是會是好的
也會是對的
就是它算是
就用悲觀的Library去做分析
可以得到比較可靠的結果
那另外一組Library是Minima Library
它通常是比較高的電壓
比如說1.1V的正常電壓
然後比較低的溫度
這樣子Library
Sale在這個環境之下
它的Delay值會比較小
它的速度會比較快
那我們也是在後態的時候
會使用這組Library去做分析
因為後態是要求Sale不要跑太快
它能夠多後的住一段時間
所以我們一樣就是用相對悲觀的那組Library
去做後態分析
那最後我們會需要一個Compensation Table
Compensation Table就關係到Equation的數值
所以在傳統的那個組別上面
其實我們也只給它一個Equation的Table
那十年前
大概我們就把這些檔案都準備好
丟到Tool裡面
其實就Tool它自動就可以去做Timing分析了
但是當進到MMMC的環境之後
就不是這麼單純了
就我們要再多做更多的事情
那剛才提到的是
我們在傳統上
我們只要有一個STC File
我們可能有Maxima的Timing Library
就有Maxima Library還有
Mima的Timing Library
然後可能有一個RC的Table
這樣子就可以做分析
但是進到MMMC之後
我們就必須要把這整張圖把它建構起來
才可以繼續
Tool才有辦法使用
所以我們要先把左邊這個STC File
應該說我們要先建一個Control Mode
並且指定說
STC File是屬於Control Mode
那我們要建右邊這個Maxima Library Set
我們要建一個Library Set叫Maxima Library Set
然後把一些
Library、Timing、Library File
都指定到這個Maxima Library Set裡面
然後Mima Library Set也是一樣
要先建一個Mima Library Set
還有先建RC Corner
然後把RC Conference Table
也是指到這個RC Corner裡面
那在接下來
我們就要建Delay Corner
一個Delay Corner
它就是由一個Library Set
加上一個RC Corner組合起來
就叫做一個Delay Corner
所以在這裡我們就可以做出
Maxima的Delay Corner
跟Mima的Delay Corner
那現在我們有兩個Delay Corner
我們也要
跟Control Mode的組合
一個Control Mode
一個Control Mode
加上一個Delay Corner
組合起來就叫做一個Analysis View
所以我們也可以產生出
一個Maxima的Analysis View
跟一個Mima的Analysis View
那最後還要再去設定說
如果它在做效態分析的時候
它要分析哪一個Analysis View
就是Maxima的Analysis View
那做後態分析的時候
需要分析哪一個Analysis View
就這樣子就算
MMC設定完
那這是什麼意思
它的意思就是說
Tool它做timing
它有timing最佳化能力
然後它有timing分析的能力
那當它在做效態的
不管是Analysis
或是後態的
不管是Analysis
不管是分析或是最佳化
它會知道說它需要分析
這一個View
那它分析這個View的時候
它會知道說這個時候
它需要去參考的
那個content file是哪一個檔案
就它的那些timing的內容
它的clack要設定
多少
然後它可能有一些
一些Io的
一些參數的資訊
它要怎麼設定
它可以從這張圖去找到
這個content file的位置
那另外它需要去做
計算pass的delay
計算pass delay它就可以找到說
它需要使用的那個
delay的corner是哪一個delay
corner
那因為計算delay的時候其實
也分成兩件事情
一件是etration
另外一件就是去做
timing的計算
所以etration的時候它會知道說
它可以使用哪一組etration table
去做etration分析
然後算出來的etration
那個rc的結果負載的結果
去換算sell delay的時候
它要用哪一組library
去換算它的sell delay
所以就是
整張圖就是它的連結
就到時候它要去做
分析的時候它可以找到
所有它所需要的資訊
這個就是MMMC的設定
它叫multi-mode
multi-corner的
那為什麼
會需要把事情搞得這麼複雜
就原本我們
就只要給它library file的檔案就好了
為什麼需要把事情弄到這麼麻煩
原因是因為delay變複雜了
就在越後面delay
其實我們看到
幾乎都是有multi-mode的狀態
一個delay它可能
有分成不同的mode
因為在操作不同功能的時候
它所需要的
clk的設定
或是io的設定其實是不一樣的
所以它可能有不同的操作模式
所以這種東西我們叫做multi-mode
那對於這樣的東西
我們就可以寫三個sdc file
分別去對應它的操作
它的mode
就因為不同的mode
它的clk或設定可能不一樣
所以我們就可以有三個不同的sdc file
各自去描述
這樣我們的sdc就會變得比較簡單
就不需要把它
強迫合成是同一個
所以它那個sdc就變得比較複雜
那另外delay分析的部分
我們的delay
我們的晶片可能會操作在不同的電壓
所以不同的電壓我們可能
就需要去做不同電壓的分析
所以也許我有一伏的電壓
有0.6伏的電壓
所以我們可能就會需要分析不同電壓的timing分析
然後我們的製程
也許它在
上面提供了不只是一個表格
就從設定以後
rc的table其實都是
五個以上
就rc table其實它都有分
很多不同的rc table
那我們可以挑想要的來使用
就我們的rc table可能
可以有不同的table
那這個時候
mmc就看出它的作用了
就我們可以把這些組合
都全部它的delay corner
都組合出來然後concrete mode都組合出來
然後再各自組合出
有可能會發生出
有可能會發生的analysis view
然後再去指定說
哪些analysis view在做self
態分析的時候要分析
哪些是在做後態分析的時候要做分析
那tool它在分析self
比如說它在分析這個view的時候
它就可以去回溯說
它的concrete
還有它的delay的計算
要怎麼樣去做計算
它可以各自去找到需要的資訊
在這個狀況之下
mmc就很有用了
這為什麼我們
要把
timing設定要變得這麼複雜
原因就是因為design本身
變得複雜了
所以前面我們看到
mmc的browser
它其實就是在設定
這張圖
我們必須要先把library set
先設定出來
library set和rc corner
還有concrete mode這三個
這三項要先把它設定出來
所以mmc browser
就要先把library set這個地方
還有rc corner
還有concrete mode
先把一些檔案
先把它指定進去
然後把library set
加上rc corner
組合起來就叫做delay corner
所以在圖上的話就是這兩個block
我們要把一個library set
加一個rc corner組合起來
就叫做delay corner
所以這delay corner
就會設定在這裡
最後是第一個delay corner
加上concrete mode
就叫做inertial view
所以在左邊這個地方就會
建立很多個inertial view出來
所以應該是
這兩個inertial view
就把它建起來
再更後面設定說
Cell太分析和後太分析
要分析哪些
Analysis view
也是一樣
Cell太分析我要分析這些view
後太分析我要分析這些view
這個就是mmc的browser
第一次接觸人
大家一定是有點不大熟悉
但是你一定要
慢慢地去適應
因為這個算是一個
進入到physical
的一個門檻
你如果跨不過去的話
後面基本上都不用做
現在也沒有傳統的
輸入介面
就只剩下mmc的輸入介面
所以你一定要先把這個地方學會
OK
應該還算蠻清楚
大家
做的時候
就試著把這個東西看懂
所以
Delay input完之後
接下來這個步驟
叫做Global net connection
我們剛才也提到過
在
Netlist之後的Netlist
它實際上它只有
定義
上面的連線
可是實際上每一個原件
它都會有VDD pin和VSS pin
所以Netlist裡面
並沒有去定義這些VDD pin
VSS pin到底弄到什麼地方去
Tool
它要求我們把它定義清楚
它沒辦法去做一個模糊的
控制
我們這些線到底要接到什麼地方
它一定要非常的
清楚
所以我們必須要把這些連線資訊把它
補足
要怎麼做 做完就是
Global net connection
的這個
實裝
裡面
Default它這個Connect這裡會放在Pin的位置
Instance
BaseNet這個Default
Default它會放一個信號在這裡
信號就是Wirecard的意思
表示說這個信號是
可以代表任意的字串
在這裡
的意思就是它代表
任意的
Instance 所有的Instance
的意思
PinNet這個地方我們會填入VDD
在下面ToGlobalNet這個地方
也會填入VDD
它代表的意思就是說
我們希望把
所有的原件
所有原件的VDD pin
Connect
ToGlobalNet
VDD
所以上面
的VDD表示的就是
Sale的VDD pin
就是每個原件上面的VDD pin
然後下面的這個VDD
表示的就是它的
GlobalNet
VDD的GlobalNet
而這個Net的名稱
是在前面做
Default輸入
前面做Default輸入
的那個名稱
我們回去看Default的
視窗
在PowerNet這裡我們輸入一個VDD
表示就是
幫我們產生出一個GlobalNet
的意思
所以這個VDD在
後面GlobalNet Connection的時候就
馬上就用到了
我們實際上就是把所有Sale的VDD
要求它連線
它算是在Connectivity
上面的定義上
我需要它把VDD連結到
VDD上
這些東西都設好以後再按
Add Tool List
在左邊Connectivity List就會多出影響
所以VSS
也是做同樣的操作
那另外還有一個
模糊的那個
操作狀況是
我們的Design裡面可能
會有一些連線
它是連接到1B1
或者是1B0的連線
Velloconnection把它
把Net連接到1B1
我們知道它是連接到
Logic1的意思
但是對APR Tool來說
這個1B1其實是一個
不明確的定義
因為實際上
在Layout裡面沒有任何一條Net
叫做1B1的Net
我們實際上沒有
任何一條Net叫這個名稱
所以這條Net到底在
拉線的時候到底要拉到什麼地方去
其實就需要
再更詳細的定義出來
所以它可能可以
這樣子它可能可以直接
連接到VDD上面
假設我們要把它直接到VDD上面
我們就要在
同樣左邊的GlobalNet Connection的視窗這裡
在Type-high這邊
把它先打勾
就選擇Type-high,Type-high指的就是
1B1的意思
我們就變成要求它把1B1
連接到GlobalNet VDD
所以到時候它拉線的時候
就會直接拉到VDD的Net上面
但是把
Sale的Input Pin
直接連接到PowerNet上
它有個風險是
ESD很容易去穿過
這個電源的路徑
進到這個Sale裡面
就我們來的進電的效應進電突破
很容易就會
從這電源的路徑就
破壞這個Sale的
輸入它的Git的位置
所以做出來的
底下的量率可能就會變差
所以
現在Sale Library
其實都會提供另外一種Sale
叫做Type-high Sale或是Type-low Sale
Type-high Sale
一個Type-high Sale它
就只有一個
Type-high Output Pin
它沒有任何的Input Pin
它就只有一個Output Pin
這個Output Pin固定的就是
吐出1B1的訊號出來
因為它有一些
保護電路座在這個Sale裡面
所以它比較不容易
被ESD打穿
那當我們的電路裡面需要
1B1的連接的時候
裡面就加上Type-high Sale
它就可以把它連接起來
只是說
加Type-high Sale這個工作
它是在Pressman之後做的事
那我們現在在
還在Design Input階段
我們現在Design Input階段
需不需要去
連接這個Type-high的連接
其實不連其實也沒關係
但是我會建議大家
把它連接起來
原因是因為我們就算現在
把Type-high Sale先連接起來
就先把它連接上去
之後做完Pressman之後
再去加Type-high Sale
Tool還是會去把它打斷
然後重新用Type-high Sale
去做連線
所以
多做這個部分其實
算是買保險的意思
如果我後面忘了做
那我至少前面還有一個
還是可以連接上去
那另外一個用意是這樣子
另外一個用意是
這個Global Net Connection
操作完之後我們其實會
要求它去做檢查
就它有那個
底下有個Check的功能
Tool它會去檢查說是不是還有
定義不清楚的地方
那如果我們在這個時候還有
1B1的連線還沒定義的話
你就會看到很多的那個
Warning的訊息跳出來
那有時候Warning訊息會把
真正該
就這麼多的Warning訊息它有時候會把
真正的錯誤把它掩埋
在裡面
所以我們就最好是把這些
訊息就把它
先清除掉就是我連
Type-high Sale和Type-high Sale都先把它
定義好那剩下
還如果還跳出訊息的話就表示
那個可能就是真的錯誤
的地方
因此
大概我們知道
一個Design我們就會先把VDD的
連線VSS連線
Type-high和Type-low就把它定義好
定義完之後就可以
按Check去檢查是不是還有
任何還沒定義到
還沒定義到的位置
如果都OK你就直接按Apply
然後它就離開
這個視窗
然後
GlobalNet Connection定義完以後
這個Design的連線
才算是完整的定好
接下來我們還要再做一個
工作叫設定
Process Note
我們要告訴它說我現在這個制程是哪一個
Process
就45奈米的制程就可以
寫40的話就寫40
90奈米就寫90
這個變數它影響
它影響到的其實是
R系缺懸的精密度
在越先進制程
在以缺懸的時候它需要的
精細度其實是越精密
比較傳統制程它以
缺懸的時候是可以不用這麼
精細的缺懸
所以如果我們在
90奈米之前
因為它Default這個
變數它Default的
Default是90奈米
如果我們在90奈米之前
不去設這個變數
那其實沒有關係
反正我以缺懸的時候
一吹的比較細
只是多浪費時間而已
對Design其實不會有太大影響
但是如果是在
90之後的制程
就應該要去設這個變數
我們要告訴它說我現在是哪一個制程
讓Tool去自動調整
它以缺懸的精密度
這樣子以缺懸出來
這個精密才足夠
這算是必要設的一個變數
再下來是
CheckDesign
就我們Design Input完以後
建議大家
會再去做一下檢查
就用CheckDesign去做一下檢查
那為什麼需要這部
這部其實只是檢查
它是幫我們把一些
比較容易犯的錯
把它抓出來
因為我們
就是手動操作
就是人類去操作這些東西的時候
多少都會出錯
就我們可能不小心少給了
一個Left
或者不小心少設定了一個Timing Library
或者說VolgModule我可能少給了
一個檔案
Volg可能是好幾個人做的
其中一個檔案忘了
輸入進去
錯誤
最後的結果都很嚴重
然後它其實
不容易被發現
當我們少做了
這件事情之後
可能要到很後面
做到很後面的階段才發現說
我原來前面犯了一個錯誤
變成要整個回頭再重修
所以
呼爾它提供的一些功能
它可以自動的去幫我們把這些問題
抓出來
讓我們可以去檢查說
是不是不小心犯了某些
錯誤
建議大家在真正在
跑一個Design的時候就還是要做一下
CheckDesign
這個畫面跳出來之後你就把它全部
打勾就如果你不是很確定
就把它全部打勾到直接按OK
它就開始檢查
檢查項目比如說剛才提到的
就是少了一個Left
或是少了一個LIB5.1的Gear
或者說
Left裡面可能少定義了某個Pin
這可能算是
Library的問題
或者是
如果這個Block
是User自己設計的
那可能就是User要去把這個地方修好
或者說
我們的某一個
忘了接
Iopad
它就變成說IoPo直接
連接到Code裡面去
某一條訊號忘了接Iopad
那它就直接連接到Code裡面去
那這個時候
在CheckDesign的時候也會
把它抓出來
或者是Design如果可能有一些
結構上的問題比如說MultiDriver
或者是NoDriver
的一些問題
它也都可以
幫我們抓出來
嗯
所以
就剛剛提到過
這種錯其實都是一些
很愚蠢的錯
我們其實犯的這種錯都不大好意思
跟別人說我因為這個東西
結果多浪費了兩天
那其實這個浪費了兩天
是盡量能夠避免
盡量是不必要的
所以我們最好就是在
真正要開始去做
工作之前呢
Design input完之後就可以先做一次
CheckDesign去檢查看
有沒有一些比較
看得到的錯那有的話當然就可以
盡早把它修掉
這個是CheckDesign
然後接下來我們就直接
再進到下頁
就進到FlowerPlan的階段
Design input完之後我們
第一個要做的是先做Initial
FlowerPlan那前面我們
有提過
InitialFlowerPlan其實很單純
我們就是要決定CoreArea
的大小就是中間的這個
核心區域的大小
那決定的方式是用兩個
數字決定第一個是Ratio
就是我的長寬比
這個CoreArea的長度
高度除以寬度
就是我的Ratio
那Default都是設成1
如果大家沒有額外的考量
就是把它設成1
這個是Utilization
Utilization
它的定義是下頁投影片
Tool把我們的底帶吃進去之後
那它可以計算出
我們所有的StandardSale
和我們的Memory
BlockHardBlock的面積的總和
所以它可以自動的把
所有的Sale的面積全部加總起來
然後我們會提供給它一個Utilization
的數字,比如說0.5
然後Tool它就
使用這個Utilization
去產生出對應的
CoreArea的大小
所以因為Utilization設定0.5
所以這CoreArea到時候產生出來的面積
就是我的
所有Sale面積的兩倍大
所以就產生出來的面積
就是這麼大
也就是說
Utilization它其實是0到1的數字
它是一個小數點數字
0.5、0.6、0.7
的這種數字
最大就只有到1
那我們用這樣的數字
去告訴Tool說
它幫我們產生出這麼大的
CoreArea大小
這個面積在後面
在這個階段產生出來之後
在後面其實就不會再去更動了
除非說
流程整個拉回到
最前面這邊再重做
不然的話到後面
做完這個步驟之後整個Chip的面積
其實就是固定下來
那至於說到底該用多少
這個數字該用多少
建議上就是你就直接用0.7
就對了
因為0.7它其實是一個
不會太難做的數字
做出來的結果也不會太難看
就是你的Density不會太小
就應該說
不會說整個裡面的空間
很鬆就不會太難看
在APR上也不會太難做
所以你可以先用0.7去做
假設你做出來0.7結果
你希望再把面積再壓到更小
就可以再用更大的數字去
去做設定
然後在
這個階段我們還要去設定
四個數字
CodeToLeft、CodeToRight、CodeToTop、CodeToButton
這個數字
這四個數字是用來定義
Code和Io之間的
這四個Channel的大小
在這四個Channel
就這一圈Channel是要
給PowerIn拉線使用的
所以
就我們要先把這個位置
把它預留出來
InitialForbund
就這樣子而已
InitialForbund其實
不會太困難
比較困難的其實是後面這一步驟
叫做Forbund
Forbund指的是說
我們希望說
規劃我們的Block的位置
主要是HardBlock
就是Memory的Block
我們希望規劃Block的位置
然後讓
APR流程能夠
最順利的完成
就我希望因為我Block的規劃
Block安排的關係
能夠讓我們的Design能夠在
最小的面積之下
能夠把它做出來
因為面積就是我們的Cost
就是下限的經費
所以我們希望用最小的面積
把這個Design做出來
那這麼小的面積
除了要能夠做出來
我們就希望
它的繞線能夠順利的繞出來
然後它的
繞線擁擠度能夠
做到最輕微的狀態
Forbund之外
我們希望說
它的Time也能夠Meet
也就是說
我們希望說
Design的Forbund能夠讓這個Design
很順利的繞線完成
它的Time能夠滿足我們的要求
這樣子這個就是Forbund的目的
但是
Forbund其實是一個
很抽象的名詞
就我們當然知道說我們要規劃這個
這些Block的位置
但是沒有人
可以告訴我們說
它到底該怎麼做
一般來說
我們就所有在Placement之前
的那些動作
都算是Forbund的工作
包括說
擺放這些Io
IoPin的安排要怎麼擺放
那我到底需要加多少
至少PowerPad或是GroundPad
那我的
Macro或是Module
的位置要放在哪些
地方
那我放在什麼位置
那我可能會加一些其他的Blockage
那這些東西都是在Placement之前
做的工作
那這裡都算是Forbund的
工作
我們希望說做了一些事情讓Tool
能夠最順利的把這個底帶
做出來
所以我們就叫Forbund
所以後面的部分
我們就是分成這幾個部分
分別根據Block或是Module
或是Blockage去介紹說
我們到底有哪些
事情可以做
Invoice把一個
底帶刺進去之後
它Default就會把HardMaker
我們的SRAM放在右邊
右邊的地方
然後SoftModule我們的ValveModule
放在左邊的地方
所以我們要做的工作就是
把這些Block HardMaker
把它抓到Layout裡面去
就把它抓到某個地方去
這樣子的工作就叫做FullPlan
聽起來也是蠻單純的
難的地方就是說
到底要放在什麼位置
所以流程上
一般來說我們會
先讓Tool去整理
就
Tool它本身有能力可以去做
Block的Placement
它可以去做一些
Condition的計算
或是連線的計算
去計算說那個Block
要放在哪些位置
所以我們可以去呼叫這個功能
PlaceMaker
這個功能
它自動幫我們把Block擺進去
那尤其是
在後面的設計
其實我們現在看到很多設計
它的SRAM
動不動就是一兩百顆的SRAM
就這麼多的Block
我們也不大可能
用手動自己去擺動
所以
依靠Tool去擺其實也算是
一個很重要的工作
就是必要的流程
所以這個算是
反正我們會先讓Tool先死的去擺看看
那擺完之後我們大概
會去判斷說
它擺的東西能不能理解
就我們根據我們自己的
對底帶的那個
架構上的認識
我們能不能理解說
這個Tool
它擺出來的樣子是不是
跟我的架構比較相似的
架構
那如果我們覺得某些部分
是需要修改的
我們一樣可以去用Move的這個功能
去手動再去搬動它
那擺完的結果我們可以再去手動搬動
去排成其他的樣子
就可能搬到別的地方去
那也有可能說我們搬完的
某些部分之後
我希望把那些部分把它先固定下來
這麼多的Block
我可能先把某幾個固定
比如說這兩個東西我可能想先把它固定下來
那我希望說我把這兩個
這幾個固定下來之後
其他的部分讓它再去改一次
就當我把某些Control
先定死以後
再讓Tool再重新去做安排一次
那這時候做法就是
我先把它搬動好以後
然後去設定那些
我可以選擇某些
Module某些Block
然後把它Fix住
把它的位置把它Fix住
Fix住之後
再去重新執行PlaceMaker
那Tool就會
就會按照我們現在的狀況
再去做一次Place
所以來來回幾次大概
看看說我們
盡量的讓Tool擺出來的樣子
是我們可以理解的那個位置
那最後就把所有的
Block都把它Fix掉
把它Fix起來
這個就結束了
然後
Tool它還提供了一些
Tool Bus
Tool Bus可以讓我們把Block擺得
比較整齊
就把Block擺整齊其實是
很重要的一件事情
因為Block擺整齊Power線才比較好拉
那這個Tool Bus
它的選單在這裡
你可以選這個功能
它就會跳出Tool Bus
實際上Tool Bus很長
它的視窗很長
我把它切成十份
這十份我把它切出來
實際上它是連結在一起的
我們可能可以設定某個數值
設定某個數值
要求它針對這些Sale去做Shift
給它平移多少距離
那可能可以要求說
某些Sale它全部
對齊右邊
然後左邊全部各自
Spacing保留多少
每一個
選擇好幾個Block
Block和Block之間保留多少
Spacing
從左邊開始對齊還是從
右邊開始對齊
或是對齊中間或是對齊上面
那也可以做Alignment
指定說所有Block
所有選定的Block全部向上對齊
或是向下對齊
這個叫Alignment
我們可能可以把某些Block
做Flip
或是做Rotate的動作
這個是
在Tool Bus裡面提供的功能
大概就是我們會把Block
先擺好
照我們想要的方式擺好
整個擺完之後再把它Fix下來
這樣子這個Block就算完成了
OK
其實時間算差不多
我們今天上課就先上到這裡
那有同學
如果有問題的話可以
可以現在問
其他的也許可以做Level或是先下課
所以
有沒有人有問題
應該現在可以直接發言吧
宇辰在嗎
我在
