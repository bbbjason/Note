好,那我們來上第二門課
有聲音嗎?
有啦
這一門課的話
這一節課啊
我們要上這個finite state machine
這個地方,就是part 2的這個地方
這一課比較輕鬆一點
我們會講finite state machine
進階的一些
這個技巧
然後會給大家看一個very long的example
然後
very long寫完嘛,你要驗證你的程式
是不是正確嘛
所以要看怎麼去做這個
simulation,就是模擬
好
那
finite state machine呢,是這個東西啊
應該交電的時候其實也有教過
就是說,你在設計你的
design的話,你應該要知道說
我們大部分可能會有一個counter
就是說,這邊是一個紅綠燈的情況
紅綠燈的例子
它就是紅燈
把它數9個cycle,然後變成綠燈
綠燈再把它數9個cycle
然後變成黃燈
黃燈再數2個cycle
變回紅燈,這樣子
這是一個finite state machine
就是你可以畫出這個圖
去設計,在設計你的電路的時候
可以幫助你的
這個思緒去釐清
那
這些灰色的呢,它就是state
所以呢,我們就會有一個變數字叫state
它會控制說state什麼情況下
是等於red,等於green,或等於yellow
那如果是
如果在某一個state的話呢
你裡面的一些variable
它就會有特定的功能
在另外一個state呢,你的variable就會有
不一樣的功能
可能它這邊就是紅綠燈嘛
所以就是RGB,欸不是
紅燈黃燈綠燈,3個去
變換,這樣子
如果是function的話,這裡可能會寫一個function
這裡可能會寫一個function
這樣function可能會做不一樣的事情
在不同的state,不同的變數
可能會做不一樣的事情
那
ok
所以
這個
這個是finite state machine
基本上呢,比較小的電路的話
寫起來就,這個state可能會比較
FSM可能寫起來比較無聊
可是在比較
大型的電路的時候呢,這個東西可以
很有效的幫助你,釐清你的思緒
包含我們剛剛說
你譬如說
我們說debug的時候會有那個
所有時間點你都要知道它在
幹嘛之類的
說實在的,你這個這個
有的時候電路跑起來啊,它可能有
數十萬、數百萬個cycle
那
你說這數百萬個cycle,我都要把那個電路圖
全部用手畫的畫出來嗎?
不可能嘛,就是
你應該只要知道說
它錯,它什麼地方會錯
什麼地方發生錯誤
那它在這個地方的時候,我們這些變數
有沒有,哪裡沒有正確運作
簡單說呢,就是你
如果你用不同的state的話呢
我們可以看到,它在黃燈的時候出錯了
那我們就去看state等於yellow的時候
然後它的counter有沒有運算
正確,然後它這些燈號
有沒有運算正確,這樣子
所以你有這個state的時候呢
有這個file state machine的時候呢
包含state的變換是不是正確
然後變換state之後
這個state裡面的
運算是不是正確,這些
都可以幫助你去
更好的debug,那程式
看起來也會更有多機性可言
這樣子
不然如果你沒有用這個東西的話,通常
寫完code之後大概兩個禮拜,你就忘記
那個code到底在寫什麼
尤其是verilog其實可讀性
相對於一般的軟體來說
相對於,相較來說是比較低的
所以就是比較不好讀
好的
所以呢,加入了這個file state machine
的設計之後呢,你的這個
verilog code可能就會變成這個樣子
這裡是
一部分的這個範例
就是我們前面有一個,上一份投影片
有一個範例嘛,那這裡是把它
把它切成一塊一塊的給大家看
就是說,這邊是
state transition,其實就是我們
剛剛說控制freeform的東西
它就是always block,裡面有
passage clock,有reset
然後這個,它去控制
state跟count,是一個counter
然後
這就是freeform的宣告,這樣
然後呢,這邊就會
寫說next state logic,就是說
我什麼時候我這個state要
變換,那這邊可以
看到呢,我們就從例子裡面可以去學說
欸,很長啊,這個
左邊這邊啊,它都是訊號
然後next訊號
然後在這邊的操作呢
很常就是next訊號在左邊
然後右邊是一個
function或者是一個
數字之類的,總之呢
就是左邊常常next訊號會寫在
這裡,那這邊也是
這邊它就不是next訊號,因為
這些其實都是wire
這個地方呢,它把它切成這樣
就是說,這邊只控制state
的變換,就是state這個variable
它只在這邊控制
你always block可以建立很多個
你可以只要每一個block
裡面沒有重複的變數
就可以,就如果你
寫兩個always block,結果都有控制
next state的話,那
它就會,電腦就會不知道說
欸,那我到底要看哪一個always block
勒,對,所以
基本上就是,你可以看到這個
always block裡面有next state
那這個always block裡面呢,它只控制
這個
r、g、y這三個
這三個變數而已,那它就是
如果你在哪一個state的時候呢
它就會output這個樣子
state等於red的時候,它就output這樣
green的時候就output這樣,yellow的時候就
output這樣,那其他的呢
你就default
好
那
對,這邊就是
recap一下,就複習一下
我們剛剛為什麼會有這個x跟nextx
這樣,這個東西呢
就是我們剛剛說,欸這個是一個flip-flop
那
這個flip-flop呢
我們剛剛也,其實也大概都講過了
那這邊只是重新畫一個圖
就是input
可能是d嘛,放在d這邊
然後它是next state,output就是state
那這邊多畫一個就是
combinational logic,就是這邊其實就是
sequential,然後這邊就是combinational
combinational你就可以想像說它就是
計算計算計算,計算完之後
它就吐出來,可是flip-flop就
不一樣,它就是
要等到clock變動之後,它才會吐出來
所以combinational計算完就吐出來
然後
這邊就是等clock變換
之後再吐出來,那
你的電路就會是很多個這個
很多個這個flip-flop,然後經過一些
計算之後,然後再進入
另外一排的flip-flop這樣子
很多排很多排這樣子
然後
這邊呢,我打一個星星是什麼東西呢
就是啊
基本上電路的所有IO
建議
強烈建議都要用一個register
擋下來,除了這個clock
跟reset這種
所謂的控制訊號以外
基本上就是clock不要擋
reset不要擋,剩下的如果
你搞不清楚的話,就
用一個flip-flop把它擋下來
那擋下來你要怎麼擋呢,那可能是
input是一個一個一個譬如說
是一個enable好了,input是一個
enable,那你這邊就隨便取一個變數
這樣子,然後照這樣子的宣告的方式
或是你enable等於
一個譬如說譬如說我現在
就是next variable 1
等於enable,那我這邊就可以
用next variable 1,然後output
就是variable 1
這種重複取名字的東西
是ok的,你可以想像說我們
剛剛說,你沒寫一行就多
一塊電路對不對,那
我們剛剛說,這邊我們說如果是
next variable 1
等於enable的話
那其實就是一條線它是enable
enable接接接
接到這邊,然後它就變成
有另外一個名字叫做next variable 1
然後output是variable 1
所以這邊它其實就是
一條電線而已,一條電線對我們來說是
沒有成本的
幾乎可以說是沒有成本的,而且其實
compiler會把它核掉啦,所以其實
沒關係,就是取名字
你讓它有next variable
跟variable這樣子
的邏輯的話
你的程式可讀性也會比較好
所以呢
回到原點就是說
其實enable
算是比較像是control signal
所以不用
prefile擋下來其實也是可以的
但是就是如果你不知道
一個變數要不要用prefile擋下來
那就是擋
除了clock跟reset以外
就一定要擋
這個東西
有一點
有一點難解釋
但是
很容易會造成大家後面
design會
發生非預期的情況
反正variable就是這樣
它就是一個有點像是規定
沒有定的很好
盤拍的沒有寫的很好那種感覺
反正就是你寫起來之後它就會有一些
地方明明code也沒有bug
但是它就是會出一些
非預期的情況
所以就是
有一些奇奇怪怪的規定
那這個的
理由是什麼呢
我可以用
稍微放給大家看一下
好了
這個我用白板寫
所以其實錄影的話就不會錄到
不過
應該還好
好
我這邊有一個data
in
然後我這邊有一個
next
計算
來個計算
然後
好
好
大家可以看這個
基本上外界的input
這個datain
那這個東西我們說要用對付
要擋下來
那理由是什麼呢
datain它可能隨時都在跳動
如果我們的電路
是要在cosm這邊去操作的話
我們就可以看到說
這邊都在跳動
然後到某一個地方的時候
譬如說我的code是寫這樣
就是next flip flop
譬如說
我這邊是assign
next flip flop等於
data
in
然後我在一個
always flop裡面
我
我說這個flip flop
這個always
裡面有一個flop的這個
就是sequential
然後箭頭next flip flop
那其實畫出來的電路
就是會變成這個樣子
就是這是一個flip flop
然後這個是next flip flop
然後boot是flip flop
然後它接過來
其實是這個
這個datain
大致會長這個樣子
所以你可以想像這兩個其實根本就是一樣的東西
它就是條件是有不同的名字
那這樣子寫的原因
是因為我要讓它
就是名字有這個next跟
一個變數這樣子
那回到
這個我們原本要講的事情
為什麼我們要用隨手打起來
同學呢這兩個東西應該會是一樣的
所以這個東西就是
跟這個東西應該會是一樣的
但是呢因為它硬是外接的東西
所以它是助教給的
test bench裡面寫的
那我們不一定要在什麼時候
我可能在這個時間點變動
可能在這個時間點變動
我不知道
所以呢
你用一個flip flop
把它打下來的話呢
如果我這邊說這個flop它是
pass edge的話
那我們要看pass edge
那這個flip flop它就一定會在
pass edge的地方
它的值才會改變
對不對它只有在這邊的時候
值才會改變然後改變成下一個
然後在pass edge的地方
才會改變
所以呢
我這邊呢第一筆資料在這邊
它就變成第一筆資料
原本發現這兩個東西它是
幾乎是同時變動的
因為它就是一條線
也不是說幾乎它就是同時變動的
可是呢
我這個第一筆資料會在這邊
才進來
所以在這個cycle
這是一個cycle
第一筆資料會在這邊的時候才變動
那這樣有什麼好處呢
我們剛剛說這邊啊
它有可能data in會在這個地方變動
會在這個地方變動任何地方都有可能
但是你如果用一個
flip flop打下來的話
我就確定說
這個資料一定會在某一個pass edge
之後才會給我
它才會變動
那這有什麼好處呢
就是說我們有時候要做一些
combinational的運算嘛
combinational的運算是需要
花費時間的
你要跟它做加減乘除
它不是一條線傳過去就好
那你要跟它做加減乘除的話
它需要一段時間去計算的話
你在這邊變化之後呢
你有一個完整的cycle
可以計算
可是啊如果你沒有用flip flop打下來的話
你就必須被迫
只用這段時間去計算
所以
你可以計算的時間就少很多
那它可能就算不完
算不完
線路就會出錯
它就會算到一半然後給出一個
就像你考試寫到一半的答案
那老師就會給你扣很多分
這是一樣的意思
你算到一半
如果說我這邊叫它去算一個東西譬如說
data叫它去平方然後再什麼
除以五之類的
很奇怪的計算
反正它就是會假設算不完的話
那這個就會不夠算
就很極端的case
我到這裡都還在變動
那我就只剩下這麼一點點的時間給你算
那就會不夠算
那這樣子你就會確保
你有一整個cycle的時間可以去做事情
所以大部分
其實我們都
除了clock跟reset以外
還有控制序號以外
其實大部分都是data
data這個東西
data相關的東西
都用flip flop打下來
data output都一樣
就是資料從外界輸進來
資料要輸出去外界
之前第一件事情都是用flip flop擋下來
這樣子
在後面的作業
會讓你輕鬆很多
會讓你少很多麻煩
你要抄嗎
要抄掉囉
不然我用那個
不然我用這個起來
再來我要講一件事情
在講這個東西
是因為
之前我們說
我們的homework 1
homework 2
接下來是homework 2
再來應該是homework 3
再來是這個
這個project
然後homework 2
大家要寫的東西是very long
然後homework 3
大家要做的事情是把它合成
gate level
跟transition level
也就是layout
那麼
這個過程中
我們剛剛講了很多很多的
規定
有一大堆規定
有一些東西是語法上的規定
有一些東西是語法上雖然會過
但是functionally會錯誤
的東西
那這些事情
這些單單的規定
什麼時候要等號什麼時候要用箭頭
什麼case要補齊不能用net
反正一些奇奇怪怪的規定
其實在你作業2的時候
幾乎都沒有關係
什麼意思呢
就是你不照這些規矩寫
作業2可能還是會過
很有可能會過
以初學者來說
我們會說very long跟軟體語言
其實是還蠻不同的
思維
我們有時候會說初學者
寫very long的時候會用C的概念
去寫very long
還會想要圖方執行
簡單說就是不照我們剛剛講的東西去做
那
這樣寫出來的very long code
很恭喜
homework2很可能你會pass
但是homework3
跟project
project其實就是再給你另外一個題目
把homework2跟3再重做一次
重新寫very long
到Klevel到Layout
但是project可能難度比較高一點
回到我們剛剛講的
very long在homework2的時候
會對
他才會驗證
譬如說我們剛剛說後面有流程
跑了什麼tour之後他會告訴你有沒有Latch
homework3才會做
跑了什麼tour之後
他才會告訴你說
時間上
算起來像這個地方
我們說這個時間比較長
這個時間比較短
homework2沒有
homework2在Klevel之前
所有的運算都是瞬間完成
所以homework2你這樣寫不會錯
因為他的運算就是瞬間完成
他沒有時間概念
homework3的時候
Klevel開始才會有時間的檔案
有一個叫standard delay format
的檔案
這個我們可能下禮拜才會講到
但是就是
Klevel才開始有時間
時間觀念他才知道
運算要花多少時間
因為他要去估算嘛
運算要花多少時間
homework2都是你寫的
他不會告訴你
花多少時間
他會在瞬間運算完成
這個問題就不會發生
那這樣子的話呢
就是你homework2寫一寫之後
想說這不會簡單嘛
我其實開學的時候有說
我們的作業難度其實是這樣
然後到這邊的時候飆上去
就是因為
就是因為
homework2你隨便寫隨便過
我跟你講
你寫完之後
最好是去把它改的
符合我們說的東西
因為
你如果沒有符合我們說的東西
你homework3的時候呢
homework3其實很簡單
就是你把homework2的東西丟進去
跑一跑tool按照步驟按一按
結果就出來了
你一行課都不用寫
結果就跑完了
如果你寫跑的東西是對的的話
我們這邊還會做testing
但是如果你沒有照著我們說的東西
做的話
那後面的testing就不會過
那testing不會過怎麼辦呢
你要回來改這個東西你知道嗎
你要回來把它全部重寫
你要把它改掉改成正確的東西
所以其實homework3就是
很可能你要重寫很多次homework2
所以我們才會說
它就會飆上去
就是因為你要寫很多次
什麼東西要改什麼東西要改
發現自己後期篩到各種地方都沒有符合規矩
最後就把整份code刪掉
然後你又只剩一個禮拜
然後跑這個後面的tool其實很花時間
就是那個電腦太爛了
有人就會寄信說度假跑半個小時正常嗎
跑一個小時正常嗎
拜託我碩頓的時候那個day out的時候
累了兩天的樣子
所以你如果在最後一個禮拜
然後突然說homework2很簡單嘛
那我最後homework3
最後三天再來寫就好了
結果你寄信跟我說你們寫不完
我說掰掰
然後就把那個停修的單子寫一寫給老師
所以
講這個東西是要告訴大家
第一個插入project.io很重要
為什麼
因為你不插的話homework2會過
那homework3你就要重寫
那你頭就會很大
那你先把它插好
後面就會少了一些事情
然後再來就是
homework2大家應該會
很快就把它寫完
所以晚一點寫或許還好
早一點開始
那你才會發現說你到底要不要重寫homework2
那
所以呢
以往啦
我們會把homework2homework3合併成一段時間
然後讓大家寫
譬如說四個禮拜好了
譬如說四個禮拜好了
然後
大家就會在最後一個禮拜開始寫
大家可能在這個地方寫homework2之後
發現欸簡單嘛然後就去玩
然後在這個禮拜開始寫
然後發現這邊要重寫homework2
然後就爆了
所以我們這次是把homework2給大家
時間比較短一點
然後交了之後你就要開始寫homework3
所以後面這段時間
大家要早一點去做homework3
就是一個提醒啦
免得發生這種悲劇啦
我不希望收到一大堆這種新聞
我一起來會很累
大概就是這樣子
所以.io的重要性在這邊
就是其實啊
大部分人寄信給我啊
有時候大部分的問題
其實最有可能就是
io沒有檔好
其實coding style大家都會去看
投影片然後就知道說
coding style應該要怎麼樣
然後我沒有符合所以出錯了
大部分人都可以
但是沒有檔到io
是有一點難察覺的
這是大概是兩大
第二大
會寄信給我code會有問題的
問題
就是沒檔io
那第一大就是我們前面說的case沒有誤期
就會有dash
那個東西是第一名還是第二名
所以呢
盡量要把io檔起來
好的
應該就這樣
好那再來就是一些比較
進階的語法
就是如果你用到的話
再來查這個投影片
也還可以
隨意聽聽
這邊是什麼東西呢
是一個for loop
大家要注意
跟你想像中的for loop完全完全
不一樣
完全就
不是一樣的東西
他這邊的for loop呢
他有一個特別的語法
就是我們先直接看這個for loop
他就是k等於0到2
然後
然後就begin end
然後有個out括號k
這個東西呢
他完全不是執行for loop的事情
而是把k從0到2
把他帶進去然後把他展開
所以呢你就可以看到這個output k
箭頭next output k
他就變成output 0箭頭next output 0
到output 2箭頭next output 2
他就只是把code複製
複製k份這樣子
然後幫你把那個變數帶進去
跟你想像的for loop一點關係
就沒有
他就只是把code展開
這樣子而已複製展開
這樣子而已
就是因為你在寫這種code的時候
有的時候就是會有很多的排
排線或者說我們說很多
就是很多一個array之類的
所以你不會想要
把這種東西如果output有0到
127有128個
你不會想要把他全部
寫出來所以你就會用for loop
寫起來比較快
那
語法就是長這樣子
那下面這個是什麼東西
下面這個也是一樣的意思
就是這個是在
conventional的這個是在sequential的
他就會長這個樣子
然後他這個for loop
他展開就會變這樣子
他就只是展開而已
這個就是完全等異
完全等價了
好
那for loop的話呢
我們剛剛說要把所有的condition都
寫負7寫清楚
這邊就有一個錯誤的跟正確的case
是for loop的時候
你可能就會遇到一些狀況
不好意思
這邊不是for loop
這個就是複習
case一定要補齊
這非常非常重要
非常容易出錯
所以有一個always block
clock c next c
這是我們正常寫的
這邊呢
在什麼條件下呢
next c等於什麼東西
要不然的話next c等於什麼東西
這個if他就沒有
對應的else
那他就會少一些情況
就少一些情況他不知道怎麼辦
所以呢這邊就要把else的情況
也把他補齊
那我們說補齊的時候呢
自己等於自己其實就是用這種寫法
就是把這個free swap的
就是相反
就是input接到output這種感覺
就把他接回來
好那這個呢
就是我們剛剛說for loop的情況呢
你也要把他補齊
那for loop的情況呢就會有一些特別
譬如說呢
這邊宣告了一個for loop的
這個ck
那ck是等於0-15
k是0-15所以c就有0-15
那你這個
這個always block呢他就只有
只有0
那這個雖然有if有else
0的情況補齊了
可是1-15這些剩下的
nc1-15他就通通都沒有
那他也不知道要怎麼辦
所以呢
你這邊就應該要把
1-15的情況也寫清楚
就是這邊是if else
所以這邊就是if
然後nc0然後nc的1-15
就用for loop等於自己
這邊也是一樣下面這邊也一樣就沒有寫
就是1-15這邊也要寫
好
那
所以
這樣那再來呢
有另外一種補齊的方法
就是有兩種holding style
這是兩種都可以的
我們剛剛說啊
這個nc1-15
nc1-15
這個這個
你可以寫說nc0
然後下面寫nc1-15
或者是你可以在最上面這邊
這個always block這個combination的部分
或者是sequential
sequential應該不會用到這種東西
combination的部分呢
你可以在最上面給一個
類似default value的感覺
你這裡面會動到的變數呢
都可以都把它寫在這裡的話
那
就可以不用在這裡面補齊
所以呢這邊就會有
nc1-k
他就會是k-0到k-15
所以你會發現這邊也有nc0
這邊也有nc0
那就是會以下面的為主
所以就是會在上面先有一個default value
然後以下面的為主
這樣子
那這邊也是一樣
這邊呢我們就可以看到
這個錯誤範例
就可以看到他是if然後begin
然後這個if else
然後上面這個if他就沒有對應的else
但是因為你最上面有nc等於c
這個東西你已經先寫了
所以這就是一個default
那如果下面沒有什麼東西的話
他就是會執行這個
所以他就有把
所有的case補齊
那
這個東西的優點就是
比較好寫
比較方便
但是他有一個缺點就是
你的code寫起來就不會像我們前面說的
很對稱
很對稱其實
視覺上會比較好debug
比較好抵出這種
你看不對稱就知道少東西
但是這種的話呢你就會發現說
這邊有if然後他沒有else
但是這個code是正確的
那他就比較不好debug
那我們前面講的那種
就是把他寫在
補齊的那種寫法
他就比較對稱
但是寫出來code就會比較長
然後寫起來手打的比較酸
之類的
那這兩種都可以寫
也沒有
我個人是比較喜歡
比較繁瑣的那種因為比較好debug
不過
就是隨便大家都可以用
那for loop也一樣
就是你先在上面寫一個for loop
然後就有default value
再把下面
再把你的function寫進去
所以這邊如果else是等於自己的話
你甚至可以不用寫else
他就會跑這個case
好
這是一個替代方案
大家如果不喜歡的話就
用我們前面講的那種就可以了
然後memory
memory其實我們前面大概講過
就是你register在assign的時候
在宣告的時候
在宣告的時候你後面可以加一個
這個長度
那就是前面是bit數
那後面是這個
variable的個數
所以他這邊就可以宣告
memory有1024個
然後他是有16個bit
所以可以看到他用parameter
bit數他就是16
然後memory就是1024
因為他從0開始數所以就會有
word size-1跟memory size-1
還要注意是從大到小
跟從小到大
然後memory呢
一樣你如果想要開2D的話也可以開2D
開2D的話就是
再多一個中括號
可以看下面的例子
他就會變成2D的
他就是
什麼這是7個bit
他是7-1
0-7-1 0-7-1
所以就是7749他這個memory就有49個
然後每一個16個bit
這樣
然後這個是
onsign跟sign的number
那這個東西應該
大家都有學過
所以就是onsign跟sign的number
就是你一樣的
一樣的數字他會有
他會有不一樣的解讀方式
所以呢default應該都是onsign number
那如果你要用sign number的話
你要特別宣告
這邊呢
你就可以看到這個地方我們就特別宣告
一個sign
如果是sign number的話你就要寫在這裡
register也是一樣就寫在這裡
然後bit數然後你的variable
那要記得
就是
就是
你在操作的時候要很小心
就不要說什麼用一個onsign去跟一個sign的
number去做加法
減法之類的運算之類的
就是你要運算的東西
他們就應該要是一樣的
一樣的這個
一樣的型態啦
就是你要想說
你要是想說你寫這個code
然後你自己
想說不知道他會做什麼事情的話
那很可能
電腦也不知道要做什麼事情
所以他就會有一個奇怪的default的做法
那可能就跟你想的不一樣的話
那就會出問題
反正就是onsign跟sign要小心不要混用
那像這個數值呢
這個就是如果有sign的話
就是三個bit然後他是sign
然後是binary
這個
三個bit的sign
binary number 111呢
他就是-1
然後這個a他是-3
因為a我們宣告的這個是
在這邊他是sign的
所以呢他這個東西出來就會是-3
這個c就等於
什麼a加這個
反正算起來就是這個樣子
雖然這兩個值看起來是一樣的
可是因為a跟b一個是sign一個是onsign
所以他出來的值就會不一樣
順帶一提這個是
裡面的comment
就是你要註解的話可以用這個東西
兩條斜線
好
那
好這個是
這個也是sign跟onsign的東西
就是
就是
如果你的input啊如果你要運算的東西
是onsign的話
那你的operation就是
只要有一個input是onsign
所以你
就是我們說盡量還是要讓
要運算的東西統一才不會出錯
這樣
下面有一些example大家可以回去看一看
哪裡他的這個
邏輯上可能會不符合預期
這樣
好的
那再來就是一個design example
給大家看看就是
有點像是在複習
前面講的東西
隨便聽聽隨便看看
那
好的這邊的話呢
其實我們前面還沒有講說
什麼有講說什麼
同步的這個reset
非同步的reset
那這邊的話呢就可以看到說
如果作業的這個spec有給你
應該會給你下面這個
就是告訴你說你的reset
是asynchronous active high
asynchronous是非同步我們前面講過
那如果是active high的話呢
就是可以看這邊
就是他的reset是上去的
就是當你在high的時候
他才會active
所以就是reset等於1的時候
那如果是active low就是他全部都是1
但是會掉回0一下下
然後再全部都是1這樣
那就是他是非同步的
非同步你可能就是
always裡面就要有clock跟reset
然後因為他是active high
所以你就要看passage
passage reset
然後這個clock他也會寫
passage的clock
這個電路是對passage的clock
那clock也是
就會變成always add
passage clock或passage reset
這樣子
寫起來就是這種感覺
下面就是我們剛剛列出來的東西
這是一個
很簡單的circuit
他如果叫你
開始數就是一個down這個訊號
叫你開始數
從10數到0
然後
從10數到0
然後就維持
然後0維持兩個cycle之後
然後再變回10
然後等待他再叫你開始數
喝個水
好
0會維持兩個cycle
那
從10開始
這個number就會是10
然後直到
input告訴你
上面這三個都是input
下面這個是你的
那叫你開始down
之後你就開始往下數
數到0經過了10個cycle
然後0再等一個cycle之後
再跳回10
等待他的這個訊號再拉起來
所以你可以看這個例子
整個電路啊
是一個不斷的重複的東西
就是說
他有一個有點像是standby
或者是我們在做這個
finite state machine的時候會有一個state叫做idle
就是他在等待
那這個state呢
idle之後呢
他會等待外界的控制訊號
再告訴他說你要開始做什麼事情
那他才開始進入各種不同的state
那最後呢就是算完之後
會回到idle state
常常會設計成這個樣子
那下面這個地方就是你的debug的介面
我們剛剛前面有講過
那你可以看到這邊有一點點紅紅的
紅紅的地方呢就是
這個模擬的軟體
不知道這邊的值是多少
那不知道這邊的值
是多少的原因呢
是因為他還沒有reset
所以reset會給他一個最initial的value
剩下的情況下
你都是debug嘛
那你把output接回input嘛
那你這個variable就不知道他是什麼東西
所以他output接回來也不知道是什麼東西
所以就是紅色的
裡面會寫XX
那只有在這個
reset之前
有XX的話是ok的
reset之後有XX就表示
有一些情況下電路不知道發生什麼事情
就沒有了
所以你不能讓reset之後有XX
reset之後有XX常常是
你的code有bug的地方
那常常我們說這種東西
都是一個訊號傳給另一個訊號
另外一個訊號計算之後再傳給
下一個訊號
所以你就可以看到XX是一個斜斜的一排
就是這個會XX是因為上一個XX
上一個XX是因為前面這個XX
然後你再找到第一個XX
然後去看你的code哪裡造成
他是紅色的XX
然後去那邊debug
所以看這個黑色的介面
這個東西叫nwave啦
就是用這種方式去debug
所以
就是有一個idle state
他就是會countdown
叫你數就開始數
數到count等於0
然後維持一下0然後回到idle
這就是一個標準的
finite state machine的寫法
大家可以自己稍微看一下
因為字有點多我不想看
那寫起來呢
就長這個樣子
其實呢
我們說
他就是一個NUM
那
我們剛剛其實是說
最好是用一個free file
把他擋下來
所以他就是用一個count
count就有count跟nextcount
然後num也有num跟nextnum
反正他就是有多用一個free file把他擋下來
不是只有一個
那這個
這邊呢就是跟前面的東西是一樣
只是說他把這個next state logic
就是我們說
你的next state要怎麼控制
他寫在這裡
然後把一些其他的計算寫在下面這邊
反正就是你要把他拆開還是一起寫
在同一個always block裡面
都可以
因為這個程式比較簡單
基本上就是你一個always block裡面
控制的變數
我個人啦
會覺得相關的放在同一個always block
然後相關的就擺在一起
然後不要不同的always block
控制同一個訊號就好
所以你可以切成多個
也可以只用一個
sequential part就只會有一個
那所以這邊呢其實就是
next state logic是綠色的一些
那output logic
是紅色這些
然後對
反正就是這樣寫
然後大家就可以看到前面就有叉叉
然後紅色的
這個就是一開始還沒有reset
你看一reset
一拉起來他就馬上有值了
這個就是你給他的initial value
可以再去前面對照剛剛的投影片
看看他是怎麼寫的
這邊就是一大堆我們前面看到的東西
那
就可以看到說count
是一個倒數的東西
然後我們說
剛剛說他有一個count
然後output是number
所以我們就可以看到說count跟number
他在這裡啊
就有一個cycle的差別
這就是我們說擋一個flip-flop
所造成的效果
他的速度呢就差了一個cycle
所以你在debug的時候你就可以從這裡面去debug
就是number某一個地方錯了
那他就表示他上一個這個count可能錯了嘛
對不對就是有點類似這種方式去
倒推
那用這樣子去debug
那這邊有state他state有0跟
1跟2
大家看黑板
應該不會字太小啦
0跟1跟2
這就是我們剛剛說的idle state
跟down state跟zero state
這東西就是你parameter如果定
定這個名字的話
就比較
在程式裡面就自己比較看得清楚
這樣
那
這一頁的重點其實是要讓大家看說
多擋一個flip-flop他就會慢一個cycle
慢一個cycle你就說跟其他的
計算如果沒有同步怎麼辦
我要怎麼
同時要用
跟另外一個訊號的話
那多了一個cycle怎麼辦
那其他的訊號就再用一個
flip-flop把他擋下來反正就是用flip-flop
把所有訊號都調整到一樣的時間
然後你要去
計算的話就可以拿他來計算
總之呢
就是你可以想像flip-flop會
讓訊號再慢一個cycle
再開始變化
這樣子所以所有訊號就會往後推移
一個cycle這樣所以你在debug
的時候如果發現我的這個訊號
他的
他的抵達時間跟我想像的不一樣
那你就用flip-flop多擋幾層
擋到他這個
同步為止然後他
是你要的時間為止
所以這就是一個flip-flop
就是我們剛剛講的嘛
你clock每次變動他就會跳一下
因為你這邊如果在接一個
後面再接一個flip-flop
他就必須要經過兩個clock才會到output
所以就會慢一個cycle
是這種感覺
我這邊的note
也是寫說強烈建議除了clock跟
reset跟控制訊號以外
所有input output都用register擋下來
這個down呢
他就是一個控制訊號
控制訊號有點像是他一告訴你
你就知道該開始做什麼這種感覺
那你也可以用這個
控制訊號呢當作說
我有點像是因為flip-flop都
有點像是你要提前一點
知道說我等一下要幹嘛這種感覺
不然就要再等一個cycle
再開始做一些事情
總之呢就是控制訊號告訴你
一些訊息之後呢
你就知道說我等一下要開始幹嘛了
那你就可以開始做一點點準備
這樣子
那聽起來有點複雜
反正如果你不知道是不是控制訊號
就是除了clock跟reset以外
你都可以把他擋下來
你還是可以做到一樣的事情
好
那最後是RTL simulation tool
那synthesis是合成啦
就是我們剛剛說把verilog變成gate level叫synthesis
那synthesis我們今天不會講
因為
因為作業2沒有嘛
作業3才會有
那我們下禮拜才會講
很累
所以我們這邊呢就會告訴大家說
你怎麼去驗證你的RTL的code是否正確
那在231工作站呢
就是你會需要先設定一些東西
反正我們要用的軟體
叫做ncverilog
那所以呢你就要去source一些檔案
那nweb是我們剛剛說
黑黑的那個底的那個debug tool
所以呢你要去source
這些檔案
這些就是你就去
路徑應該沒錯
我記得我檢查過路徑應該沒錯
如果路徑有錯的話趕快寫email告訴我
我再發公告信跟大家講
應該是沒錯啦
那就是你要source這個檔案
然後才可以使用這兩個軟體
這樣子
就是你要使用軟體
很多都是要先source一遍
然後他才可以執行
好
那ncverilog要怎麼使用呢
就是你指令就打ncverilog
然後testbench就是
測試的一個檔案
測試檔案這個助教會給大家
就是會是叫做
testbench或是testfeature
什麼什麼什麼.v
他是一個.v檔verilog都是.v檔結尾
就是testbench
然後你的design在這邊
也是一個.v檔
加ss加r
中間要有共白啦
加ss加r
然後這樣子他就會跑一次simulation
然後跑完simulation之後呢
我們的testbench裡面
有寫一些指令
讓大家的程式會
輸出
可以給nwave讀取的檔案
所以後面我們就會告訴大家說
要怎麼去讀取這個檔案
那nwave是一個有圖形化介面的東西
所以你就要打一個end
去讓他在
開出視窗
在背景執行
ncverilog就不用
按下去之後他就跑完
然後告訴你說你的結果是正確的還是錯誤的
正確的你就不用開nwave了
錯誤的你就要開
就這樣
好
那我們可以看一下剛剛那個
指令啊
你的testbench.v
你的design.v
加ss加r
加ss加r是什麼東西呢
他就是可以去
就是給他一個讀取的ss的這個權限
那你不加這個東西可不可以呢
可以但是你的nwave就不能debug
他就是讓你去
寫nwave檔案的一個指令
那如果你確定
一定會正確的話呢
不加也可以
那你就沒得debug了
如果錯了你就沒得debug了
這樣子而已
那我們的作業呢
通常啊應該會是用fsdb檔
就是在這個
testbench裡面呢他會
testbench裡面其實寫起來
就可能會是像這個樣子
其實有一點亂但是
有一些原因啦就是
fsdb檔
我剛剛說的原因
是工作站的問題啦
反正大部分的情況我們應該是使用fsdb檔
但是
vcd檔也是有
一樣的功能但是他就是比較
舊版的東西然後格式比較大
反正這些歷史上的
淵源啦反正就是工作站有一些太舊了
所以他就只有vcd檔
之類的還是什麼fsdb就不能讀取
之類的通常建議是
叫大家換工作站啦然後使用fsdb
因為他比較小比較快之類的
那
所以code裡面才會有
fsdb dump file
dump variable
dump file
那
因為這個作業
應該已經公告出來了所以大家其實可以去
去看
然後是另外那個助教
等一下會來講這樣
所以我不太知道他是用fsdb還是vcd
這樣
好應該是
fsdb啦
好那再來就是
要怎麼debug呢
ncverilog
那他就會跑指令碼就會去compile
然後去執行simulation
那simulation結束之後呢
這邊可能就會有跑這種
start然後1開頭的
這個就是error
反正就是什麼inspecting a semicolon
這個分號
就是他
你有一地方沒打分號啦類似這種東西
這種就是
如果你最後有error的話
那就是你的語法有錯誤這樣
有錯誤的話他就會開始做模擬
那模擬出來呢就會有一個
結果告訴你那你可能就要從模擬出來
結果的這個
數值去驗證你的
design是否正確
好那如果說
design想要debug的話呢
就要開nweb我們剛剛說nweb
然後打一個end
那他就會開出右邊這個視窗
那這邊就有file open
你就點file open
然後選某一個fsdb檔
我們這邊是counter.fsdb
作業應該不是啦某某東西
.fsdb
然後點ok就是這邊
按open之後就會開出這個視窗
那這個視窗呢你就去你的資料夾
裡面找到這個fsdb的檔案
然後按ok
那就把它打開
好那我們來把
剛剛沒有講完的部分稍微講一下
這個就是我們
剛剛說這個
vcd的這個投影片
vcd跟fsdb
那我剛剛問過助教
他說xpans裡面兩個都有寫
所以就是看大家需求啦
但是建議大家還是換工作站換到有
沒聲音
沒聲音嗎
有嗎
建議大家還是換到有這個
fsdb可以運作的工作站為止
好
那再來就是
這個
nwave一些簡單的操作
這邊就是你剛剛讀取檔案之後
那這個
這邊可以signal然後get signal
那get signal之後呢就會跑出右邊這個畫面
這邊就是你宣告的一些
variable一些變數
這些這個register wire
都會在這邊
選一選你想看的訊號
包含input output clock
reset這些東西可能
會用到
那你的state
next state也可以點開
但是通常是差不多的東西
然後count
output應該也會有一個number
就是我們剛剛的舉例
按ok
他就會全部列出來
那這邊就會有這個時間軸
按就可以按放大或縮小
縮小的話他就會
就是會把範圍看的比較
就是可以看的比較大
這邊是按放大
他就會變的比較
看起來比較長
反正就是zoom in zoom out
那這邊也是如果你要快捷鍵的話
這個是open file的快捷鍵在這邊
get signal的快捷鍵在這邊
那這些signal其實也可以
上下移動你要怎麼排列
你可以用滑鼠去抓抓看
不過因為操作也不是很
就是會有點卡
大家用過工作站的tool應該都知道
他就有點卡然後又有點陽春
反正就是
不是很好按就對了
然後你也可以譬如說按著這個地方
按到這個那個滑鼠左鍵
按著然後拉到這裡
然後他就會把你按的這一段
放大之類的
100%就是
時間軸最長到哪裡他就會把他全部顯示出來
然後你就會看到這個clock
變得很密就是一條
完全時薪的線這樣
好
最後就是這個
一個小小工具
就是如果你這個count
你想要用16進位去看
他default都是用16進位
16進位就會有a這個東西出來
那你可能想要用16進位
看比較好看就點
這個訊號然後按
signal value radius
那把他改成decimal
他這邊就會有2進位
actual應該是8進位吧
16進位10進位ascii code也可以
但是我們注意好像沒有用到ascii code
反正就是各種
不同的顯示方式他就可以改一下
這樣幫助你debug
跟讀取
讀值方便這樣子
好啦其實就是三張並不是很
關鍵的投影片但是因為剛出了
一點小問題所以我們就把他補齊
那接下來我們就請另外一位助教來
講解作業
作業2的一些細節
作業2作業3啦
好
