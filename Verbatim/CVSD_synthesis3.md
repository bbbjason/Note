是關於使用Design Compiler來進行Synthesis
還有關於Get Level Simulation
這一部分的Part 2
那就今天繼續跟大家介紹
那我們先回顧一下
上個禮拜講解過的內容
上個禮拜比較重要
今天也會用到的是Logic synthesis
這個過程
它含蓋了哪些的步驟
整個Logic synthesis的工作
就是把我們的RTL code
轉換成最底層用End or或者是Fifthup之類的
這些Gate們
它們所組合起來的Gate Level的電路
RTL到Gate Level
這個轉換過程是使用自動化的Tool
也就是我們的Design Compiler
所以在這個轉換過程中有兩個步驟
第一個步驟是Translate
就是HDL Compiler
會幫我們做
在Terminal上會顯示Presto Compilation這個步驟
會先在Read File或者是輸入Ellaborate
這個步驟會把RTL初步的翻譯成
是GTAC這個格式
GTAC如果大家上週還有印象的話
Synapses它自己中介的一些Gate跟一些檔案
這種檔案就不是針對某個Technology
例如說.13自成,.18自成那種的
而是只是Design Compiler內建有一個
可以表示這樣邏輯的電路
加減層出也不會展開到底層
Fifthup之類的
也是暫時有一個功能性的Fifthup style
而不是真正的Technology
Library裡面的Cell
在我們下完各種Constraints
還有我們提供好的
主要是Technology Library
Technology Library就會有
這個自成裡面的各種Cell
還有它們的Timing, Area, Power
之類的Information
還有我們自己的User為了這個Design而下的
關於Input Output
關於Clock的Cycle
的一些假設
這些Constraints都下好之後
我們就會用Design Compiler把
G-Tech這個格式
進一步轉成是
我們目標Technology的Gate Level的
Gate Level的電路
上禮拜我們提到過整個過程
具體來說
我們首先準備好的RTO
在Design Compiler裡面
要使用正確的方式
去Specify好我們的Library
上禮拜也跟大家講解過
比較重要的Technology Library
和Design Wear Library
需要正確的去引入
所以我們的Design Compiler才可以
依照Technology Library裡面的Cell
來計算Timing
來拼出我們要的那個Function
接下來是Read File
然後HDL Compiler
就是轉區Tag的步驟
會在Redesign這個步驟裡面發生
接下來要設定各種的參數
Setting Design Environment的部分
在上禮拜提過了
那可能包含
Operating Conditions
包含Wire Load Model
還有Input Output的
Load跟Drive
還有一些Delay之類的訊息
這些Constraints
這些條件統整Design Environment
然後後面還要設定
其他各種Constraints
這就是今天之中
會主要涵蓋的部分
接下來我們設定好了
我們有了RTL
有了Library
還有各種Constraints
跟我們的Environment之後
我們就會Compile Design
這一步就是會花最多時間
Design Compiler會進行最佳化的
就會用Technology Library裡面的Cell
去把GTag裡面這樣子的
Function給拼上去
然後盡量去Optimize Timing
還有Area他們的要求
所以最後就會得出一個
Gate Level的Netlist
上禮拜講到Design Environment的設計
今天就從Design Constraints
往後面繼續
今天比較大的篇幅
會在Design Constraints上面
這篇依照性質
就大概分成四項
跟大家做介紹
首先第一個是Design Rule Constraints
這個是在合成的時候
算是相對比較硬性
就是不能夠去違反的一些規定
它的Priority是比較高的
第二個部分是關於Clock的Constraints
因為我們在計算Timing
之類的東西的時候
Clock這個訊號是非常重要的
那我們會用比較多的指令
來去秒速來去Model這個Clock
來讓我們的Design Compiler
可以做針對Clock Signal
傳送到各個Register
算Timing的事情做合成
然後是特殊建築的部分
會介紹False Pass
Set False Pass這個指令
還有關於Clock Gating相關的指令
最後則是和我們的
Optionization的目標有關的
例如說跟Area
或者是跟Power之類的
我們合成的時候的目標
有關的一些指令
首先就從Design Rule Constraints來看起
這邊有三個
Max Transition,Max Turnout,Max Capacitance
剛才提到說Design Rule Constraints
是Constraints裡面
Priority比較高的
就是原則上不可以去違反的規定
它的Priority是比Timing的
還有Area的規定還要嚴格
就是還要更前面的
更優先的
所以即便我的
如果設了Clock Cycle是5奈秒
它沒有辦法Meet到這個Time
它還是會遵守
下面的Design Rule Constraints
這邊通常會設定
三種的Design Rule Constraints
這三個都是針對我們
合成出來的電路裡面的Net
或者是Wire這樣子的規定
第一個設定
Max Transition
Transition這邊指的是
Transition的Time
Transition的時間長短
所以我們合成出來的Netlist
其中的任何一條Wire
任何一條Net
從0到1的時間
這個過程花的時間
或者是從1到0這個過程花的時間
就是任何一條Net
它的Transition時間必須在
我們下這個指定規定的範圍以內
以這個範例來說
不能夠超過0.1
單位是奈秒它預設的
第二個是我們
針對合成出來的Netlist
它裡面的所有Net
一樣是針對所有Net
它的電容最大值
Compassive Load最大值
不能夠超過這個數值
預設的單位應該是PF這個單位
所以任何一條Net的電容
不可以超過這個值
第三個是Max Fan Out這個指令
我們在上週提到Wire Load Model的時候
有提到Fan Out是什麼東西
Fan Out就是
我們的一條Net
除了去Drive這條Net的Pin之外
剩下其他所有Pin的總和
也就是它的Load的數量總和
所以Max Fan Out就是規定
我們一條Net接出去的
接到的人數不可以超過這個數量上限
所以我們就會
下這三條指令
Design Compiler就會在這三個
幾乎是當做前提的狀況下
即便違反Timing Area
也會遵守這樣子的狀態下去
做合成
接下來我們會介紹關於
Clack的Constraints
首先我會介紹
在Design Compiler裡面
Clack這個訊號
要怎麼樣透過一些指令
就是透過什麼方法去Model它
因為我們這邊的Clack是
不是真正之後我們Physical的Layout
它的Clack會這樣子傳遞
而是有一些Modeling的方法
那後面就跟大家介紹
大致上分成這六個部分
就是六個部分
就是會設定
Clack的指令
那首先就先講說
在Design Compiler裡面的
Clack怎麼Model
那對於一個Clack來說
最重要最基本的是它的
Period和它的Waveform
那Period指的就是
一個週期裡面有多長
那就是從這個
Passage到下一個Passage
他們中間一個週期
所經過的時間有多長
那Waveform則是
定義說在一個Cycle裡面
我有幾次的Passage
Passage那個age
他們的時間分別是多少
萬一如果真的需要Passage
就是唯一的這個區間比較短
然後唯一的區間比較長的時候
就可以用Waveform來去設定它
這是它需要的
Uncertainty則會包含兩個部分
一個是Skew
一個是Gitter
那這邊等一下會再詳細說明
不過Skew指的是
例如說我的這個FreeFap
要傳到這個FreeFap
但是他們兩個人的Clack的
Arrival Time是不一樣的
那他們兩個就會相對上產生一個
Clack的相位差
他們Clack的Arrival Time不一樣
這個就是Skew
那至於Gitter則是
每次我同一個Clack
它的Passage那個age
它的每一個週期可能多少會有點不穩定
這是有可能會發生的
那Latency的部分會有Network Latency
跟Source Latency
一般來說就是
必須要設定的是Network Latency
Source Latency是看狀況
不一定需要設定
那這個Latency指的是
我們從Chip和外界的這個Clack
要灌進來的時候的
這個Clack的定義點
和我們的FreeFap們
他們真正接到的Clack
中間就是有可能存在一個Latency
所以我們需要去Model它
那還有一個是Transition
包含Clack Transition或Input Transition
是可以分開設定
我剛才講的Max Transition是怎麼樣的
這裡的Transition就是
我預設了這個Transition的時長是多久
那接下來就進入指令的部分
第一個是CreateClack這個指令
那如果使用CreateClack這樣的指令
如下面這個鎖匙
然後取的name是Clack
Pure的是10
單位應該是耐秒
Waveform是0和5
然後這樣子去設定的話
我就會產生一個ideal的
就是完美的Clack
那它是不會有任何delay的
propagation過程傳到別人也不會有任何delay
Transition的時候也是0到1是馬上來
然後1到0也是馬上來
也沒有任何uncertainty的
那這就是CreateClack所給我們的
那這邊就稍微再講一下指令裡面的細節
這邊首先看Waveform
那Waveform依序是PassedEdge
NakedEdge他們所會發生的時間
所以在一個週期為10的period裡面
Waveform如果是0和5的話
那就是0的時候來PassedEdge
5的時候來NakedEdge
這是正常的預設的狀況
那Waveform這個argument
這個option如果不設的話
它也會自動生成就是
0的時候是PassedEdge
然後period一半的時候是NakedEdge
然後這邊我們的CreateClack
這裡有一個name是Clack
那這個東西指的是
Clack這個物件的name
我們把Clack這個物件的name套在
iClack就是iClack這個port上面
就是一個稍微小小的要注意的點是
ClackName和我們applyClack的portName
是可以不一樣的
所以在後面的時候
例如說我如果這樣子設定的話
那getClack就必須要打clk
才可以得到這個ClackObject
那如果我想要針對port來做設定的話
我就需要打iClk才可以拿到這個port
它們兩個是不一樣的Object
雖然說是指向同一個人
所以這邊是
就是萬一我們選擇有
兩個以上的Clack
你可能會幫它們取不一樣的ClackName
那就要注意一下
不過我們也可以把它們兩個的名字
就設成一樣
那通常這樣會比較簡單一點
你用getClack或者getPorts
所指向所能夠get到的人
都會是同一個
在ClackConstraints裡面的第二步
是我們一般會在
會在create完Clack之後
就接著設定的這三個條件
第一個是setFixHold
第二個是setDon'tTouchNetwork
第三個是setIdealNetwork
這樣子
那這三個指定希望大家分別知道它們的用途
setFixHold指的是
針對這個Clack我要去
修正所有的hold time問題
所以如果是
一般來說我們的比賽裡面都需要meet
setLineTime上面的
就是timing的要求
也需要fit那個meet
在hold time上面的timing要求
所以setFixHold這個是必須要設定的
它跟hold time的要求相關
那第二個是Don'tTouchNetwork
那這邊需要提到一個解釋
為什麼我們要設定Don'tTouch跟設定Ideal
是主要的原因是因為
我們在上禮拜提過WireLoadModel這個東西
那WireLoadModel會使用fanout的數量
來去估算這條net
它的長度
它的電容
它的delay之類的
但是
就是大部分的wire都可以用WireLoadModel
來去就是做個估計就好
但是Clack本身是
fanout的數量是非常非常多的
整個比賽裡面都是share同一個這個Clack
所以用WireLoadModel就會變得不太準
所以下面我們就會用一些方式來model
這個Clack的行為
就不會用WireLoadModel來去估算這個Clack
不然會不太準
好
那這邊的Don'tTouchNetwork
指的就是我們不會去針對
Clack這個訊號來做優化
我們不會對這個東西來做優化
我們不會幫它加buffer
不會對它做任何的就是
mapping上面的事情
SetIdealNetwork指的則是
我把這個Network當作是理想的
那就是
所以這條Network是不會有任何delay的
所以我就假設我的Clack未到全部的register
直接沒有delay
那是瞬間就可以起來的
所以
這就是這三個指令的意義
那
透過下面這樣子的方式去設定它
那另外呢
就是SetIdealNetwork
也不一定只能用在Clack上面
那有一些synchronous的reset
或者是我們user自己
就是選定好一些high and low的net
我們是不打算讓
就是不打算在Design Confiler這個stage
就去優化它的話
我們就可以把它設成IdealNetwork
但通常最常還是用在Clack上面
好
接下來講解的uncertainty呢
uncertainty則是
我們為了幫Ideal的Clack有更好的
就是更好的modeling
所以我們需要考慮了這個IdealNetwork的
就是uncertainty
我們另外加上去這樣子
我們需要考慮的uncertainty有Skew跟Giter這兩個
那Skew就是指的
通常是指時鐘
就是我們的Clack在相位上面的不確定
那就是
我們的
Design裡面會有非常非常多的register
會share我們的同一個Clack signal
那我們在Design Confiler這個步驟
就是還不會詳細處理Clack的性質
但我們就
那在之後的APR
就是Automatic Place and Route的步驟裡面
就是我們會把Clack使用
就是用更實際的方式來去model它
那個時候呢
我們的就是在經過APR之後
我們的Clack以達不同register之間的時間
可能
就會因為路上的buffer數量有不同
中間的load有所不同
所以他們兩個的Clack可能會稍微的out of face
就錯開一點
這個是理想的狀況
那下面這兩張圖就是他們兩個的face錯開一些的狀況
所以這是之後我們做APR
就是實際的Clack處理可能會發生的事情
所以在Design Confiler裡面
我們使用
就是先把Clack當作一個ideal network
然後搭配一個uncertainty的區間來預留給
之後的skill可以用這樣子
那至於
suit的部分呢
則是始終在
就是在頻率上
上面的一些不穩定性
那可能是一些就是
穩定性的緣故啊
或者是電源或者是溫度變化
的rise fall
就是0到1和1到0的transition time
不一定完全一致的緣故
那我們就有可能讓每個
就同一個Clack
它在不同的不同cycle裡面
它的waveform可能會稍微長得不一定完全一樣
像這邊這個
這個1就特別短
那這邊為1的時間就比較長
那這個東西
頻率上面不太確定的特性就是Git
那下面這個是更誇張的例子
那可以看到它的1的cycle比它
就是它1的時長比它0的時長還要多蠻多的
所以就是
有可能會有這樣的狀況
所以我們一樣用uncertainty去model它
來去處理它
所以這邊呢
就是我們了解了Clack在
之後更實際的處理
或者是
就是實際狀況下可能會有Skew或者是Git
這些種種不完美的效應
所以我們在Synthesis的時候呢
使用ideal network
然後另外加上一個uncertainty的
的區間
大家可以想像好就是
就是預留了一些
預留一些可以花的時間來給之後Clack的不完美效應來用
好
那在後面的那個
APR部都會
用會用的一個
mod就是
把Clack做出layout的方法是
Clack Tree Synthesis
Clack Tree Synthesis就是
時鐘序號會用一個類似tree
類似樹狀關係長出來
然後
位到就是底下裡面的所有register
那至於這個實際上是什麼的話
之後在課程裡
其實在期中考後面
APR的相關課程
會
會再跟各位提到
那另外一個是在設計的時候呢
就是有稍微算是可以參考的uncertainty的值
那小的電路可能設置成
是0.1
那大的可能設置成0.3
不過這個基本上是依照
需要去meet的那個
specification你的規格而定的
那就是不一定需要
就是看狀況而定的
那uncertainty本身也是一個trade off
如果你把uncertainty設的越大的話
就表示你預留的越少time給你的logic
然後留了比較多的time給你之後
Clack可以來
可以來skill還有jitter所使用的
所以既然你的logic能花的時間變短了
你的timing減少了
那就是基本上就是用更大的area去換
所以就會合成出面積比較大的logic的組合
那在計算timing的時候呢
我們在我們的logic所能夠花的時間
就會在這邊去減掉uncertainty這個部分
所以就會在這邊顯示出來
那接下來是Clack latency的
部分
那剛才我們也提到了clack tree synthesis做好
那clack tree synthesis做好之後
你的clack進來你的design裡面
就會經過就是蠻多的buffer
那經過不同數量buffer
來位到我們所有的register裡面
所以就是你的
你在chip的interface上進來的clack
那中間經過一些buffer
所以位到你的register的clack
是中間會經過一定的latency的
就是之後蠻可能會發生的
所以
那這個latency就影響關於input跟output之類的運算速度
那因為相對於其他的input來說
這clack latency會讓我們的register
它所在的時間相對上比較晚一點
所以需要有一個clack latency的假設
那麼在design compiler裡面
我們也是一樣先假設
這樣子clack network latency是存在的
那我們用idealclack配上這樣network latency
去model這個之後
實際上可能會遇到的delay
所以這個基本上也是知道之後的clack會做什麼樣的性質
來做設定的參數
好
那clack latency有兩種
一種是network latency
這是一般會用到的
那source latency是額外的
其中network latency指的是
我們在chip interface上面
然後這個點的clack到我register的clack
中間所經過的latency
那我們希望怎麼樣去model它
那在這邊的指定可以看到
我們可以用第一行的這個指定
那就是0.5
它就會把你的rise latency和fall latency都設定出來
如果你需要在它的latency
在rise跟fall edge去指定不一樣的數值的話
可以用第二跟第三行這兩個指定
來做搭配
那就可以設定成不一樣的數值
至於source latency呢
這是如果假設你的chip外面
你有假想一個真正的clack的起始點
那它到你的chip interface上面
還有一個額外的delay的話
我們可以用source latency來去model它
那這樣講可能有點難想像
但是其中一種就是有機會用到的情境是
如果你有多個clack
那這兩個clack它們
它們default的delay是不一樣的
我們就可以為這兩個clack設置不一樣的source latency
來去model它
不過這個還是option
就是如果要用到的話可以使用這樣
那接下來的是設置clack的全時間
和input的transition time
transition剛提過就是
clack如果從0被拉到1
或者是從1被降到0
這個transition的time會花多久的時間
這個跟剛才的max transition不一樣
max transition指的是
我每一條合成出來的net都不能超過transition
這邊的transition指的是
我假設這條進來的訊號
它就是有這樣子的transition區間
設定的方法跟剛才那個有點類似
如果你不設for跟rise的option的話
set class transition就會同時設定rise transition和for transition
那如果你需要
你需要針對rise跟for指定不一樣的transition time的話
就可以透過這樣子的flag來去指定
除了clack之外
我們也會針對input的transition來設定transition time
上面提到的這些基本上就是在clack裡面會用到的
就是我們為了model一個clack
所下的指定還有它所對應到的概念
接下來就是補充一個東西是
在我們這一週提到的clack的constraints
還有上週提到的wire load的constraints
這兩個部分有一些內容
它只是在design compiler做syntesis這個步驟
就是生成gate level netlist這個步驟裡面
暫時使用的一種估計用的model
包含上禮拜提到的wire load
就是大概只是用
就是我們只是用一個net在接到的output
它的fanout的數量去估計我們的rcdelay是多少
然後clack的部分我們也提過就是用idealclack
加上uncertainty和加上latency
來去預留一些可運用的時間範圍
給後面更實際的處理來使用
那在APR automatic place and route這個stage
在clack的部分會進行clack tree synthesis
那就如同剛才講的就是會
用一個樹狀結構來去處理不同register
兼它們的clack關係
一個clack會經過就是一個樹狀的buffer tree
來去處理它
所以那個就會是更實際的model
相對於uncertainty跟latency加ideal
至於wire的部分呢
我們的place and route的routing這個stage
它也就會生成更實際的
比較物理層面上面的layout它會長怎樣
那個時候所算出來的
就是wire的load、wire的resistance
它的面積都會比
我們這裡只是暫時使用的wireload model還要準
所以呢
那在後面進行APR步驟
我們同樣也會用到
就是前面這裡就是的一些script
但是在引進APR這些script之前
就要把這些只是在design compiler裡面
做modeling的部分給註解掉
不過這個部分就是
期中好之後的那個APR課程還有lab
會講解的更仔細
它也主要以那邊為準
這邊大家就知道說這個modeling
和這個modeling它們的用意
它們model的是什麼樣的情形就好了
那在clack的部分呢
講了就是
講了主要是
六種面向上面要設定的指定
還有一些關於clack的concept
那接下來就提到一些特殊鍵路
還有關於optinization的設定
那特殊鍵路的部分這裡會介紹force pass
還有介紹
關於clack gating的一些指定還有概念
在optinization最常用的是
關於area的optinization這個指定
那也會有leakage相關的跟大家介紹
那為了講解force pass
那在這之前要很快速的
講解一下
那在上禮拜的
就是在課程裡面我們有大概提到說
進行optimization這件事情
那簡單來說就是
design compiler配好一些gate level的netlist的組合
然後去算它的速度有多快
那舉例來說
所有的register到下一個register中間都是一條pass
那在這之前我們有提到說
舉例來說
所有的register到下一個register中間都是一條pass
我們要去算這條pass它的訊號
有沒有辦法在時間之內
在一個cycle之內的時間算完
那來不及算完的就要優化
替換掉部分的gate或邏輯
那來得及算完的就有機會可以去
optimize它的area之類的
或者其他你所設定的條件
那這邊的timing pass指的就是這個需要分析的路徑
那基本上會有四種
從input到register或是一條pass
要算它的時間timing夠不夠用
register到register也是
register到output也要算timing
那如果你的電路裡面有input到output
這樣子的一條pass
我們也需要去算這條pass的timing
有沒有符合我們一個cycle內
然後減掉往生電體
減掉delay支線之類的那些算得完的要求
那要算的這些pass就是timing pass
那這邊所說的false pass
false pass指的就是
timing pass裡面我們希望指定的例外
我希望意思就是說我希望design compiler
不要去分析這條timing pass
這條timing pass就算出現violation
就算它一個cycle算不完
或者是它的timing不會收斂
就算這樣子也沒有關係
這樣子這個就是我們
如果有這樣子的false pass的話
我們就要去設定它
那通常來說
通常來說是不太會去這麼做的
因為就是我們希望所有的pass
應該都要符合那個timing上面的要求
但是有些因為design的特性
那不管它的timing也沒關係
那實際的應用
false pass可以應用的地方呢
主要比較有可能狀況
其中一種是synchronous的
clock domain的register之間的pass
那簡單的例子是假設說
我有一個design
它有一部分的register
它的cycle是3好了
那一部分是5好了
那它們兩個是沒有synchronous在一起的
所以如果我真的要分析
它們兩個register之間的pass的話
就是會沒有辦法收斂
因為它一直在變動
那這樣子的狀況下
可能就是我們會希望它不要去看
set time跟hold time的要求
除非是你有特別
特別要求這兩個東西要有相位關係
不過這部分就也需要
在RTO層面上面有做細緻的處理
才可以把
才可以做出synchronous這樣
那另一種呢
則是可以設定false pass的
就是logically上面沒有辦法
沒有辦法propagate到的訊號
由下面這張圖的例子所示
那從這張圖來看
這邊的這個max
它們的select訊號
是相反的
所以要嘛是一個前面1
後面就是第一個max1
第二個max0
一個是1一個是0這樣子
所以呢
這邊我的max如果是選擇了A進來
那後面就沒有辦法
是接到C訊號
C訊號就不會被選擇到
或者B訊號進來的時候
就不會是
D訊號被選擇到
所以A到C的這條pass
是不會發生的
就是don't care的
don't care的一條pass
B到D也是
所以這樣子的pass呢
就定為false pass
下面這裡就可以從A到C
不需要計算timing constraint
B到D也不需要計算
不過false pass就一定和TL寫法有關
那你本來就要
designer要很確定這邊
不分析也沒問題
或者甚至我就是不要分析他的timing constraint
才可以去設定false pass
好
那
第二個
特殊電路的部分呢
是clock gating
那這邊我會先
花兩頁的
部分講clock gating
大致上的概念
後面再講解所要用到的指令
那clock gating呢
就先從左半邊的這個
RTL code和這個
這個
diagram看起
那
在這邊q這個register
它只有在
enable等於1的時候
q才會更換值變成
第一訊號
那如果enable等於0的時候呢
q就會維持原樣
所以理論上
假設q透過
普通的方法合成出來
大致上的電路會長這樣子
這邊這個register會
前面有接一個max
可以選擇是q還是選擇是d
enable訊號會幫我們選擇是
透過max選擇是q
還是d
那clock gating
的基本概念呢
就是
我去操控下面這個未進來
register的clock訊號
只有在
enable進來的時候
位給它正常的clock
在沒有enable的時候
連clock都不會來
所以既然我最後在這裡要transition
我就這裡位給你clock就好
那就如下面這張圖
有clock gating的狀況
大致上就如這個所示
那這樣子帶來的好處呢
主要是
dynamic power
可以降低
因為clock這個訊號呢
它是我們電路裡面
最頻繁翻轉的一個訊號
那我們事先把clock
這個訊號擋下來就有機會
降低一些
就是降低transition
clock頻繁transition所要花的
這個dynamic
power
當然這個也會有前面這個logic cell
的overhead
所以它就是
有好處也有相對的overhead
來達成它
這邊只是一個concept
就是conceptually
clock gating大概是希望
這樣子work的
但是這樣子trivial的clock
gating方法是有點
不是很保險的
一般來說我們是在
passage要去之後馬上
接著算邏輯嘛
假設你的enable訊號
邏輯在算的時候
不小心多翻了一兩次
那這個時候就會
非常非常危險了
因為這個
這個gated clock訊號
要位給gradient當作clock
clock訊號多翻一兩次
就是可能會有很大的問題
一個比較常見的solution
就是我們不是用這個
end gate只把enable
和clock end起來
當作clock gating用的cell
而是我們用一個
negative edge
就是negative clock
去trigger的latch
前面再配上一個
end gate
來當作clock gating的signal
那先
先講解一下
latch這個cell的功用
latch的
下面這個
部分當作是
類似clock的訊號
因為它這邊
已經接了一個inverter
是negative trigger
直接用negative trigger的latch來講
latch在clock是negative的時候
會變成
一般的會直接penetrate
過去讓enable訊號介紹
enable latch的訊號
但是
在positive這半個cycle
latch會
鎖住它現有的訊號
它鎖住它現有的訊號
就不會因為前面來的enable
而改變
所以從
我們先看enable和clock和
enable latch這三個訊號
那在這邊
clock變成full的時候
enable訊號穿透到
enable latchenl這邊過來
然後在positive
這半個cycle的時候
enl維持原樣
一直到下一個negative的
半個cycle
它才會又把enable
穿透過來
就是latch的性質
所以這樣子做
有一個最大的好處是
我們可以擋住positive
這半個cycle
來的
這個glitch訊號
即使你positive來之後
enable多翻了一兩次
因為這邊
要傳過去enl訊號
還是被鎖住的
所以它就可以去prevent
這樣子的glitch發生
透過這樣子的glitch
preventing的clock
getting cell我們就可以順利達成
我們要的這種需要的
clockgetting的方法
這邊是原理
這邊是原理的部分
希望大家知道clockgetting的用途
還有這一種cell
就是
它的waveform
大概是怎樣
為什麼它可以去擋住
這個glitch
它的好處是什麼
提醒同學一下
這種latch based clockgetting
以往我們曾經在考試的時候
畫出相關的
電路請同學去
補一下它的波形
後面講的這種
它的語法
怎麼寫這種clockgetting
同學也注意一下因為clockgetting是一個
很常用降低power的一種技巧
接下來我就繼續
講解clockgetting的指令部分
指令部分
有兩種
第一種是在大多數的狀況下
可以去使用的
只要你的register有這種
會維持原樣的寫法
如同剛才提到的這種RTL寫法
或者是第二種這種也是可以的
用conditional的
conditional的寫法
一樣是enable1的時候
才會把Q
去transition成D的值
只要有類似這樣子的寫法
在register上面
就可以它被
這樣子的clockgetting的指令來使用
我們的deci-compiler
在進行這樣子的過程中
就會自動偵測
這個沒有clockgetting
但是可以使用
就是可以採用的register
來把它換成clockgetting的cell
就會自動幫你生成
那這邊呢
是在
compile的指令後面加上
一個gate-clock的option
這個gate-clock option
就會幫助
自動做clockgetting
前面的這一部分
set clockgetting style
幫助我們指定說我所需要的
clockgetting狀態是怎樣的
那這邊的
max-fanout
指的是我的一個
一個clockgetting cell
它接出來的gate-clock
訊號最多可以為
幾個register
就可以去指定它的上限
那第二個是
pos這個
指的是positive edge
trigger的這些register
也就是negative edge trigger的
這些free file
針對於這些positive edge trigger
我採用integrated
clockgetting cell
這個等一下會跟大家解說
那
control point的部分呢
就是它可以幫我們的clockgetting
去生成一些debug用的
debug用的接口
那這部分就
就是有一些額外訊號可以做debug
可以這樣子去
control
可以把clockgetting disable掉之類的
就是
在這邊就
不會特別多做說明
就只是一個debug用的
總之用類似這樣子的指定組
就可以達成自動的clockgetting
那第二種
則是
手動寫好的一部分clockgetting
那這部分就
需要它機油上面的配合
所以這邊
我們事先寫好一個
gatedclock signal是clock
and enable的訊號
那我在
always的
always sequential block
裡面所吃的訊號就不是
普通的clock
訊號了
那所以這樣子的狀況下
design compiler
的起跑點就不是
max和register
而是已經有endgate
和gatedclock這樣子的
訊號了
所以如果是 user寫好
這樣子的RTU
的狀態下可以使用
replace clock gate
就是
replace clock gate這樣子的
指令來讓design compiler
把我們的寫好的cell
換成pitch preventing的這種
有latch的cell
好那在
clockgetting
而且confirmed完之後呢
我們可以使用
report clockgetting
這個指定
來report出所有
applied clockgetting的地方
那這邊
現在針對ICG
integrated clockgetting cell
就做個補充這樣子
那integrated
clockgetting cell指的是
Foundry已經
Foundry已經提供好
這種專門用於clockgetting的
cell了
我們在design compiler要
合成出這個
clockgetting cell的時候
如果我們沒有特別
指定的話design compiler
會從target library裡面
或者technology library裡面選出
一個latch加上一個and
來組成這個cell
但是如果我們在
option裡面指定好
integrated的話
那如果像是Foundry例如說
台積電提供這樣子的cell清單
可能有現成已經
整合好的clockgetting cell可以
用那它就會
直接用integrated cell
那通常來說這種cell的效能
就是在power
performance area之類的
效能會比這樣子拼起來的還好一點
那指定的部分
就是剛才說
會補充的
passed edge trigger
的clockgetting cell
我們使用integrated
這樣子就會是達成我們
想要的這個功能
那negative edge的
也可以
那其他
還有一些design compiler
也有辦法去做的特殊
鍵路像是
multi-code
就是不止一個cycle才要
算完的這種path
或者是
positive和negative edge
就是不同的clock edge
不同的register這種design
或者是你有多個
不一樣的clock他們可能period
不一樣或者wayform不一樣
這種的design也都
是有辦法透過RTL的編寫
和design compiler去下一些
相關指定去辦到的
在這門課的範圍內就
就不特別做介紹
列在這邊就讓大家知道一下
做一個補充
那接下來呢
則是跟
optinization就是我們的
最佳化的時候的一些目標
一些objective有關的
一些constraint
那這邊
通常我們就基本上
都會設的是max area的constraint
那我們會把max area
設定成0
那就是
其實0是一個沒有辦法去mean
的constraint就是
我total合成出來的area
絕對不可能是0但是設定為
0的話就表示我們希望
design compiler盡可能的
去minimize我們的chip area
所以就是
會設定成0這樣子
我們都會設定成0
另外就稍微提一下
是我們的
面積可以使用一個
方式來去計算它
等效的gate count
它等效的邏輯差的數量有多少個
那就是在你的technology library
裡面
technology library裡面的
to這個cell它的area是多少
就可以當作
是一個cell的大小的基準
所以之後你的area拿去處理
這個單一cell的area就可以
得出一個等效的
gate count的估計
這樣子
那這邊還有一個
關於optimization有關的
是leakage
power的optimization
那這邊需要
提一下我們做leakage
power的optimization
就是通常需要使用
就是可以使用多個VT
threshold voltage的library
那先提一下
threshold voltage就是之前在
電子學裡面
有提到說就是電子學課程
要提到一個transistor它的
threshold voltage就是它apply
在gate上面那個鍵牙有關
的一個數值
那如果threshold voltage
很高的話就表示
你必須要apply
就是你的leakage會比較小
你必須要apply比較強的電力
它才會通過去
那如果threshold voltage很低的話
就表示它的電流蠻容易就
過去的
所以速度當然會比較快
但是你的power也會比較大
所以low threshold voltage
的這些cell它是
比較快的嘛
然後也比較容易在比如說關起來的時候
它漏電會漏的比較多
所以這些cell我們就會希望
就是design compiler就會自動把它
用在critical
pads上面 timing比較緊的
這些pads上面來去讓它換快一點
然後犧牲一點leakage power
但是至於
high threshold voltage的這些
cells
它就會放在相對
上不那麼要求速度
所以用這樣子的方式來
用這樣子的cell去阻擋住比較多的leakage power
那為了達成這樣子
multiple threshold voltage
的optimization
就是我們必須要在
前面設定library的時候
就設置不止一種
threshold voltage的library
例如說有
high threshold voltage
high VT的library
regular VT的library
有這樣子不同的
technology library才可以讓我們
達到multiple VT的方式
通常來說我們可以在
一次的compile完
已經有一個
階段的
gate level netlist之後
再把leakage
optimization這個flag給開起來
之後再做incremental compiling
之後再做一次
跟更換gate有關的optimization
來讓目前現有的這些
只用比較單一的library
的cell
換成multiple VT的library的cell
進一步去減低power
這邊compile的細節
在後面也會繼續提到
我們前面
就講解完了很多很多不同的
指令
這些指令在預設的狀況下
它是遵循
這樣子的priority排列的
首先priority最前面的是design rule constraints
剛才提過
一條net
transition上限
failout上限
capacitance上限
這個是最優先的
在這個情形下去完成
合成的optimization
下一個比較重要的優先序是
timing的constraints
希望電路能夠在
一個cycle裡面
算完你要的邏輯
邏輯不能夠算得太快
也不能算得太慢
這些關於timing的constraints
也是
比power of area優先的
後面的
才是power of area
所以一般來說
design compile合成的時候
在一個cycle內跑得完它跑得過
這個是優先的
接下來才會去
optimize power of area
的部分
如果
我們在合成的時候
希望去更動
priority order
就可以使用set cause
priority這個方法
就可以用一些不同
flag來去
調換它之間的
排序優先序
下一個
接下來我們把
前面所有的constraints
所有的environment
所有library跟design
既有都納進來
都設定完之後
通常我們會進行check design
和check timing這兩步驟
這邊這個箭頭號
大魚記號指的是
我要把
輸出的文字
內容輸出到這個file裡面
所以我只打check design
沒有後面的話
就會在terminal裡面print出check design
所要print的訊息
如果打這個大魚號
再打一個檔名的話
它就不會在terminalprint出來
而是會丟到這個檔名裡面
所以check design裡面
就會自動的幫我們去check很多
design的potential problem
可能需要注意的
warning或者error就會列在裡面
也包含一部分
他認為
在合成可能會有問題的
部分
所以這裡可以看一下check design
知道
你的design
有沒有什麼特別大的問題需要修改的
check timing
幫你看有沒有什麼
path沒有被constraint到的
這邊也可以看
接下來
就是要
講解
我們在這邊
先下課休息十分鐘好了
我們等一下就會從
compile design
這個步驟
再繼續講解
可能就在這邊先下課
謝謝
